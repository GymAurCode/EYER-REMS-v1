
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  Role: 'Role',
  RolePermission: 'RolePermission',
  PermissionAuditLog: 'PermissionAuditLog',
  ActionAuditLog: 'ActionAuditLog',
  RoleLifecycleAuditLog: 'RoleLifecycleAuditLog',
  RoleInviteLink: 'RoleInviteLink',
  DeviceApproval: 'DeviceApproval',
  Notification: 'Notification',
  Property: 'Property',
  Location: 'Location',
  PropertySubsidiary: 'PropertySubsidiary',
  SubsidiaryOption: 'SubsidiaryOption',
  Block: 'Block',
  Floor: 'Floor',
  Unit: 'Unit',
  Tenant: 'Tenant',
  Lease: 'Lease',
  Sale: 'Sale',
  SaleInstallment: 'SaleInstallment',
  Buyer: 'Buyer',
  Activity: 'Activity',
  Message: 'Message',
  Department: 'Department',
  Employee: 'Employee',
  Attendance: 'Attendance',
  AttendanceCorrection: 'AttendanceCorrection',
  Payroll: 'Payroll',
  PayrollAllowance: 'PayrollAllowance',
  PayrollDeduction: 'PayrollDeduction',
  PayrollPayment: 'PayrollPayment',
  SalaryHistory: 'SalaryHistory',
  LeaveRequest: 'LeaveRequest',
  LeaveBalance: 'LeaveBalance',
  PublicHoliday: 'PublicHoliday',
  Lead: 'Lead',
  LeadImportBatch: 'LeadImportBatch',
  LeadImportRow: 'LeadImportRow',
  Client: 'Client',
  ContactPerson: 'ContactPerson',
  Dealer: 'Dealer',
  DealerReview: 'DealerReview',
  Deal: 'Deal',
  DealAgent: 'DealAgent',
  DealProperty: 'DealProperty',
  StageHistory: 'StageHistory',
  Communication: 'Communication',
  CRMActivity: 'CRMActivity',
  TransactionCategory: 'TransactionCategory',
  Transaction: 'Transaction',
  Invoice: 'Invoice',
  Payment: 'Payment',
  TenantPayment: 'TenantPayment',
  MaintenanceTicket: 'MaintenanceTicket',
  MaintenanceActivity: 'MaintenanceActivity',
  NoticeToVacate: 'NoticeToVacate',
  RentReminder: 'RentReminder',
  TenantLedger: 'TenantLedger',
  Receipt: 'Receipt',
  Announcement: 'Announcement',
  RevenueSummary: 'RevenueSummary',
  ExpenseSummary: 'ExpenseSummary',
  Voucher: 'Voucher',
  VoucherLine: 'VoucherLine',
  Commission: 'Commission',
  Account: 'Account',
  JournalEntry: 'JournalEntry',
  JournalLine: 'JournalLine',
  LedgerEntry: 'LedgerEntry',
  PropertyExpense: 'PropertyExpense',
  Tenancy: 'Tenancy',
  MaintenanceRequest: 'MaintenanceRequest',
  FinanceLedger: 'FinanceLedger',
  Attachment: 'Attachment',
  DropdownCategory: 'DropdownCategory',
  DropdownOption: 'DropdownOption',
  Amenity: 'Amenity',
  DealerPayment: 'DealerPayment',
  PaymentPlan: 'PaymentPlan',
  DealInstallment: 'DealInstallment',
  DealerLedger: 'DealerLedger',
  AccountAlias: 'AccountAlias',
  AuditLog: 'AuditLog',
  DealReceipt: 'DealReceipt',
  DealReceiptAllocation: 'DealReceiptAllocation',
  RefreshToken: 'RefreshToken',
  CsrfToken: 'CsrfToken',
  DeletedRecord: 'DeletedRecord',
  Sequence: 'Sequence',
  EntityAccountBinding: 'EntityAccountBinding',
  EntityMetadata: 'EntityMetadata',
  ConstructionProject: 'ConstructionProject',
  CostCode: 'CostCode',
  ConstructionDailyLog: 'ConstructionDailyLog',
  ConstructionCrew: 'ConstructionCrew',
  ConstructionLabor: 'ConstructionLabor',
  ConstructionEquipment: 'ConstructionEquipment',
  ConstructionEquipmentUsage: 'ConstructionEquipmentUsage',
  ConstructionInventoryItem: 'ConstructionInventoryItem',
  ConstructionWarehouse: 'ConstructionWarehouse',
  ConstructionStockBalance: 'ConstructionStockBalance',
  ConstructionGRN: 'ConstructionGRN',
  ConstructionGRNItem: 'ConstructionGRNItem',
  ConstructionIssue: 'ConstructionIssue',
  ConstructionIssueItem: 'ConstructionIssueItem',
  ConstructionConsumption: 'ConstructionConsumption',
  ConstructionBudget: 'ConstructionBudget',
  ConstructionMilestone: 'ConstructionMilestone',
  ConstructionPostingRule: 'ConstructionPostingRule',
  ExportJob: 'ExportJob',
  FilterPreset: 'FilterPreset',
  FinancialOperation: 'FinancialOperation',
  FinancialOperationLine: 'FinancialOperationLine',
  FinancialOperationReference: 'FinancialOperationReference'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "role" | "rolePermission" | "permissionAuditLog" | "actionAuditLog" | "roleLifecycleAuditLog" | "roleInviteLink" | "deviceApproval" | "notification" | "property" | "location" | "propertySubsidiary" | "subsidiaryOption" | "block" | "floor" | "unit" | "tenant" | "lease" | "sale" | "saleInstallment" | "buyer" | "activity" | "message" | "department" | "employee" | "attendance" | "attendanceCorrection" | "payroll" | "payrollAllowance" | "payrollDeduction" | "payrollPayment" | "salaryHistory" | "leaveRequest" | "leaveBalance" | "publicHoliday" | "lead" | "leadImportBatch" | "leadImportRow" | "client" | "contactPerson" | "dealer" | "dealerReview" | "deal" | "dealAgent" | "dealProperty" | "stageHistory" | "communication" | "cRMActivity" | "transactionCategory" | "transaction" | "invoice" | "payment" | "tenantPayment" | "maintenanceTicket" | "maintenanceActivity" | "noticeToVacate" | "rentReminder" | "tenantLedger" | "receipt" | "announcement" | "revenueSummary" | "expenseSummary" | "voucher" | "voucherLine" | "commission" | "account" | "journalEntry" | "journalLine" | "ledgerEntry" | "propertyExpense" | "tenancy" | "maintenanceRequest" | "financeLedger" | "attachment" | "dropdownCategory" | "dropdownOption" | "amenity" | "dealerPayment" | "paymentPlan" | "dealInstallment" | "dealerLedger" | "accountAlias" | "auditLog" | "dealReceipt" | "dealReceiptAllocation" | "refreshToken" | "csrfToken" | "deletedRecord" | "sequence" | "entityAccountBinding" | "entityMetadata" | "constructionProject" | "costCode" | "constructionDailyLog" | "constructionCrew" | "constructionLabor" | "constructionEquipment" | "constructionEquipmentUsage" | "constructionInventoryItem" | "constructionWarehouse" | "constructionStockBalance" | "constructionGRN" | "constructionGRNItem" | "constructionIssue" | "constructionIssueItem" | "constructionConsumption" | "constructionBudget" | "constructionMilestone" | "constructionPostingRule" | "exportJob" | "filterPreset" | "financialOperation" | "financialOperationLine" | "financialOperationReference"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    RolePermission: {
      payload: Prisma.$RolePermissionPayload<ExtArgs>
      fields: Prisma.RolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findFirst: {
          args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findMany: {
          args: Prisma.RolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        create: {
          args: Prisma.RolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        createMany: {
          args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        delete: {
          args: Prisma.RolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        update: {
          args: Prisma.RolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        upsert: {
          args: Prisma.RolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        aggregate: {
          args: Prisma.RolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePermission>
        }
        groupBy: {
          args: Prisma.RolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionCountAggregateOutputType> | number
        }
      }
    }
    PermissionAuditLog: {
      payload: Prisma.$PermissionAuditLogPayload<ExtArgs>
      fields: Prisma.PermissionAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        findFirst: {
          args: Prisma.PermissionAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        findMany: {
          args: Prisma.PermissionAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
        }
        create: {
          args: Prisma.PermissionAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        createMany: {
          args: Prisma.PermissionAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
        }
        delete: {
          args: Prisma.PermissionAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        update: {
          args: Prisma.PermissionAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.PermissionAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.PermissionAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
        }
        aggregate: {
          args: Prisma.PermissionAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermissionAuditLog>
        }
        groupBy: {
          args: Prisma.PermissionAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionAuditLogCountAggregateOutputType> | number
        }
      }
    }
    ActionAuditLog: {
      payload: Prisma.$ActionAuditLogPayload<ExtArgs>
      fields: Prisma.ActionAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ActionAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ActionAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>
        }
        findFirst: {
          args: Prisma.ActionAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ActionAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>
        }
        findMany: {
          args: Prisma.ActionAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>[]
        }
        create: {
          args: Prisma.ActionAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>
        }
        createMany: {
          args: Prisma.ActionAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ActionAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>[]
        }
        delete: {
          args: Prisma.ActionAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>
        }
        update: {
          args: Prisma.ActionAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.ActionAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ActionAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ActionAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.ActionAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionAuditLogPayload>
        }
        aggregate: {
          args: Prisma.ActionAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActionAuditLog>
        }
        groupBy: {
          args: Prisma.ActionAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActionAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.ActionAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActionAuditLogCountAggregateOutputType> | number
        }
      }
    }
    RoleLifecycleAuditLog: {
      payload: Prisma.$RoleLifecycleAuditLogPayload<ExtArgs>
      fields: Prisma.RoleLifecycleAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleLifecycleAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleLifecycleAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>
        }
        findFirst: {
          args: Prisma.RoleLifecycleAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleLifecycleAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>
        }
        findMany: {
          args: Prisma.RoleLifecycleAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>[]
        }
        create: {
          args: Prisma.RoleLifecycleAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>
        }
        createMany: {
          args: Prisma.RoleLifecycleAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleLifecycleAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>[]
        }
        delete: {
          args: Prisma.RoleLifecycleAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>
        }
        update: {
          args: Prisma.RoleLifecycleAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.RoleLifecycleAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleLifecycleAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleLifecycleAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.RoleLifecycleAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleLifecycleAuditLogPayload>
        }
        aggregate: {
          args: Prisma.RoleLifecycleAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRoleLifecycleAuditLog>
        }
        groupBy: {
          args: Prisma.RoleLifecycleAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleLifecycleAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleLifecycleAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleLifecycleAuditLogCountAggregateOutputType> | number
        }
      }
    }
    RoleInviteLink: {
      payload: Prisma.$RoleInviteLinkPayload<ExtArgs>
      fields: Prisma.RoleInviteLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleInviteLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleInviteLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>
        }
        findFirst: {
          args: Prisma.RoleInviteLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleInviteLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>
        }
        findMany: {
          args: Prisma.RoleInviteLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>[]
        }
        create: {
          args: Prisma.RoleInviteLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>
        }
        createMany: {
          args: Prisma.RoleInviteLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleInviteLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>[]
        }
        delete: {
          args: Prisma.RoleInviteLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>
        }
        update: {
          args: Prisma.RoleInviteLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>
        }
        deleteMany: {
          args: Prisma.RoleInviteLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleInviteLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleInviteLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>[]
        }
        upsert: {
          args: Prisma.RoleInviteLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleInviteLinkPayload>
        }
        aggregate: {
          args: Prisma.RoleInviteLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRoleInviteLink>
        }
        groupBy: {
          args: Prisma.RoleInviteLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleInviteLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleInviteLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleInviteLinkCountAggregateOutputType> | number
        }
      }
    }
    DeviceApproval: {
      payload: Prisma.$DeviceApprovalPayload<ExtArgs>
      fields: Prisma.DeviceApprovalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DeviceApprovalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DeviceApprovalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>
        }
        findFirst: {
          args: Prisma.DeviceApprovalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DeviceApprovalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>
        }
        findMany: {
          args: Prisma.DeviceApprovalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>[]
        }
        create: {
          args: Prisma.DeviceApprovalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>
        }
        createMany: {
          args: Prisma.DeviceApprovalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DeviceApprovalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>[]
        }
        delete: {
          args: Prisma.DeviceApprovalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>
        }
        update: {
          args: Prisma.DeviceApprovalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>
        }
        deleteMany: {
          args: Prisma.DeviceApprovalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DeviceApprovalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DeviceApprovalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>[]
        }
        upsert: {
          args: Prisma.DeviceApprovalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeviceApprovalPayload>
        }
        aggregate: {
          args: Prisma.DeviceApprovalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeviceApproval>
        }
        groupBy: {
          args: Prisma.DeviceApprovalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeviceApprovalGroupByOutputType>[]
        }
        count: {
          args: Prisma.DeviceApprovalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeviceApprovalCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    Property: {
      payload: Prisma.$PropertyPayload<ExtArgs>
      fields: Prisma.PropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findFirst: {
          args: Prisma.PropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        findMany: {
          args: Prisma.PropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        create: {
          args: Prisma.PropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        createMany: {
          args: Prisma.PropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        delete: {
          args: Prisma.PropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        update: {
          args: Prisma.PropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        deleteMany: {
          args: Prisma.PropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>[]
        }
        upsert: {
          args: Prisma.PropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyPayload>
        }
        aggregate: {
          args: Prisma.PropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty>
        }
        groupBy: {
          args: Prisma.PropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCountAggregateOutputType> | number
        }
      }
    }
    Location: {
      payload: Prisma.$LocationPayload<ExtArgs>
      fields: Prisma.LocationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LocationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        findFirst: {
          args: Prisma.LocationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        findMany: {
          args: Prisma.LocationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>[]
        }
        create: {
          args: Prisma.LocationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        createMany: {
          args: Prisma.LocationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>[]
        }
        delete: {
          args: Prisma.LocationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        update: {
          args: Prisma.LocationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        deleteMany: {
          args: Prisma.LocationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LocationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>[]
        }
        upsert: {
          args: Prisma.LocationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        aggregate: {
          args: Prisma.LocationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLocation>
        }
        groupBy: {
          args: Prisma.LocationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocationGroupByOutputType>[]
        }
        count: {
          args: Prisma.LocationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocationCountAggregateOutputType> | number
        }
      }
    }
    PropertySubsidiary: {
      payload: Prisma.$PropertySubsidiaryPayload<ExtArgs>
      fields: Prisma.PropertySubsidiaryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertySubsidiaryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertySubsidiaryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>
        }
        findFirst: {
          args: Prisma.PropertySubsidiaryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertySubsidiaryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>
        }
        findMany: {
          args: Prisma.PropertySubsidiaryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>[]
        }
        create: {
          args: Prisma.PropertySubsidiaryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>
        }
        createMany: {
          args: Prisma.PropertySubsidiaryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertySubsidiaryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>[]
        }
        delete: {
          args: Prisma.PropertySubsidiaryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>
        }
        update: {
          args: Prisma.PropertySubsidiaryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>
        }
        deleteMany: {
          args: Prisma.PropertySubsidiaryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertySubsidiaryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertySubsidiaryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>[]
        }
        upsert: {
          args: Prisma.PropertySubsidiaryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertySubsidiaryPayload>
        }
        aggregate: {
          args: Prisma.PropertySubsidiaryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertySubsidiary>
        }
        groupBy: {
          args: Prisma.PropertySubsidiaryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertySubsidiaryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertySubsidiaryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertySubsidiaryCountAggregateOutputType> | number
        }
      }
    }
    SubsidiaryOption: {
      payload: Prisma.$SubsidiaryOptionPayload<ExtArgs>
      fields: Prisma.SubsidiaryOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubsidiaryOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubsidiaryOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>
        }
        findFirst: {
          args: Prisma.SubsidiaryOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubsidiaryOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>
        }
        findMany: {
          args: Prisma.SubsidiaryOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>[]
        }
        create: {
          args: Prisma.SubsidiaryOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>
        }
        createMany: {
          args: Prisma.SubsidiaryOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubsidiaryOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>[]
        }
        delete: {
          args: Prisma.SubsidiaryOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>
        }
        update: {
          args: Prisma.SubsidiaryOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>
        }
        deleteMany: {
          args: Prisma.SubsidiaryOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubsidiaryOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubsidiaryOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>[]
        }
        upsert: {
          args: Prisma.SubsidiaryOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubsidiaryOptionPayload>
        }
        aggregate: {
          args: Prisma.SubsidiaryOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubsidiaryOption>
        }
        groupBy: {
          args: Prisma.SubsidiaryOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubsidiaryOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubsidiaryOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubsidiaryOptionCountAggregateOutputType> | number
        }
      }
    }
    Block: {
      payload: Prisma.$BlockPayload<ExtArgs>
      fields: Prisma.BlockFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BlockFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>
        }
        findFirst: {
          args: Prisma.BlockFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>
        }
        findMany: {
          args: Prisma.BlockFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>[]
        }
        create: {
          args: Prisma.BlockCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>
        }
        createMany: {
          args: Prisma.BlockCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>[]
        }
        delete: {
          args: Prisma.BlockDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>
        }
        update: {
          args: Prisma.BlockUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>
        }
        deleteMany: {
          args: Prisma.BlockDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BlockUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BlockUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>[]
        }
        upsert: {
          args: Prisma.BlockUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BlockPayload>
        }
        aggregate: {
          args: Prisma.BlockAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBlock>
        }
        groupBy: {
          args: Prisma.BlockGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlockGroupByOutputType>[]
        }
        count: {
          args: Prisma.BlockCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BlockCountAggregateOutputType> | number
        }
      }
    }
    Floor: {
      payload: Prisma.$FloorPayload<ExtArgs>
      fields: Prisma.FloorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FloorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FloorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>
        }
        findFirst: {
          args: Prisma.FloorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FloorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>
        }
        findMany: {
          args: Prisma.FloorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>[]
        }
        create: {
          args: Prisma.FloorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>
        }
        createMany: {
          args: Prisma.FloorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FloorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>[]
        }
        delete: {
          args: Prisma.FloorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>
        }
        update: {
          args: Prisma.FloorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>
        }
        deleteMany: {
          args: Prisma.FloorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FloorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FloorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>[]
        }
        upsert: {
          args: Prisma.FloorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FloorPayload>
        }
        aggregate: {
          args: Prisma.FloorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFloor>
        }
        groupBy: {
          args: Prisma.FloorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FloorGroupByOutputType>[]
        }
        count: {
          args: Prisma.FloorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FloorCountAggregateOutputType> | number
        }
      }
    }
    Unit: {
      payload: Prisma.$UnitPayload<ExtArgs>
      fields: Prisma.UnitFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UnitFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>
        }
        findFirst: {
          args: Prisma.UnitFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>
        }
        findMany: {
          args: Prisma.UnitFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>[]
        }
        create: {
          args: Prisma.UnitCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>
        }
        createMany: {
          args: Prisma.UnitCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>[]
        }
        delete: {
          args: Prisma.UnitDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>
        }
        update: {
          args: Prisma.UnitUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>
        }
        deleteMany: {
          args: Prisma.UnitDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UnitUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>[]
        }
        upsert: {
          args: Prisma.UnitUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UnitPayload>
        }
        aggregate: {
          args: Prisma.UnitAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUnit>
        }
        groupBy: {
          args: Prisma.UnitGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitGroupByOutputType>[]
        }
        count: {
          args: Prisma.UnitCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UnitCountAggregateOutputType> | number
        }
      }
    }
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    Lease: {
      payload: Prisma.$LeasePayload<ExtArgs>
      fields: Prisma.LeaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>
        }
        findFirst: {
          args: Prisma.LeaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>
        }
        findMany: {
          args: Prisma.LeaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>[]
        }
        create: {
          args: Prisma.LeaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>
        }
        createMany: {
          args: Prisma.LeaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>[]
        }
        delete: {
          args: Prisma.LeaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>
        }
        update: {
          args: Prisma.LeaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>
        }
        deleteMany: {
          args: Prisma.LeaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>[]
        }
        upsert: {
          args: Prisma.LeaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeasePayload>
        }
        aggregate: {
          args: Prisma.LeaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLease>
        }
        groupBy: {
          args: Prisma.LeaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaseCountAggregateOutputType> | number
        }
      }
    }
    Sale: {
      payload: Prisma.$SalePayload<ExtArgs>
      fields: Prisma.SaleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SaleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>
        }
        findFirst: {
          args: Prisma.SaleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>
        }
        findMany: {
          args: Prisma.SaleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>[]
        }
        create: {
          args: Prisma.SaleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>
        }
        createMany: {
          args: Prisma.SaleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>[]
        }
        delete: {
          args: Prisma.SaleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>
        }
        update: {
          args: Prisma.SaleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>
        }
        deleteMany: {
          args: Prisma.SaleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SaleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>[]
        }
        upsert: {
          args: Prisma.SaleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalePayload>
        }
        aggregate: {
          args: Prisma.SaleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSale>
        }
        groupBy: {
          args: Prisma.SaleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SaleGroupByOutputType>[]
        }
        count: {
          args: Prisma.SaleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SaleCountAggregateOutputType> | number
        }
      }
    }
    SaleInstallment: {
      payload: Prisma.$SaleInstallmentPayload<ExtArgs>
      fields: Prisma.SaleInstallmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SaleInstallmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SaleInstallmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>
        }
        findFirst: {
          args: Prisma.SaleInstallmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SaleInstallmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>
        }
        findMany: {
          args: Prisma.SaleInstallmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>[]
        }
        create: {
          args: Prisma.SaleInstallmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>
        }
        createMany: {
          args: Prisma.SaleInstallmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SaleInstallmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>[]
        }
        delete: {
          args: Prisma.SaleInstallmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>
        }
        update: {
          args: Prisma.SaleInstallmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>
        }
        deleteMany: {
          args: Prisma.SaleInstallmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SaleInstallmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SaleInstallmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>[]
        }
        upsert: {
          args: Prisma.SaleInstallmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SaleInstallmentPayload>
        }
        aggregate: {
          args: Prisma.SaleInstallmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSaleInstallment>
        }
        groupBy: {
          args: Prisma.SaleInstallmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SaleInstallmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.SaleInstallmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SaleInstallmentCountAggregateOutputType> | number
        }
      }
    }
    Buyer: {
      payload: Prisma.$BuyerPayload<ExtArgs>
      fields: Prisma.BuyerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BuyerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BuyerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>
        }
        findFirst: {
          args: Prisma.BuyerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BuyerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>
        }
        findMany: {
          args: Prisma.BuyerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>[]
        }
        create: {
          args: Prisma.BuyerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>
        }
        createMany: {
          args: Prisma.BuyerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BuyerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>[]
        }
        delete: {
          args: Prisma.BuyerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>
        }
        update: {
          args: Prisma.BuyerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>
        }
        deleteMany: {
          args: Prisma.BuyerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BuyerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BuyerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>[]
        }
        upsert: {
          args: Prisma.BuyerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BuyerPayload>
        }
        aggregate: {
          args: Prisma.BuyerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBuyer>
        }
        groupBy: {
          args: Prisma.BuyerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BuyerGroupByOutputType>[]
        }
        count: {
          args: Prisma.BuyerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BuyerCountAggregateOutputType> | number
        }
      }
    }
    Activity: {
      payload: Prisma.$ActivityPayload<ExtArgs>
      fields: Prisma.ActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        findFirst: {
          args: Prisma.ActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        findMany: {
          args: Prisma.ActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
        }
        create: {
          args: Prisma.ActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        createMany: {
          args: Prisma.ActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
        }
        delete: {
          args: Prisma.ActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        update: {
          args: Prisma.ActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        deleteMany: {
          args: Prisma.ActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[]
        }
        upsert: {
          args: Prisma.ActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>
        }
        aggregate: {
          args: Prisma.ActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActivity>
        }
        groupBy: {
          args: Prisma.ActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.ActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    Department: {
      payload: Prisma.$DepartmentPayload<ExtArgs>
      fields: Prisma.DepartmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findFirst: {
          args: Prisma.DepartmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findMany: {
          args: Prisma.DepartmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        create: {
          args: Prisma.DepartmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        createMany: {
          args: Prisma.DepartmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        delete: {
          args: Prisma.DepartmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        update: {
          args: Prisma.DepartmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        deleteMany: {
          args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        upsert: {
          args: Prisma.DepartmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        aggregate: {
          args: Prisma.DepartmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartment>
        }
        groupBy: {
          args: Prisma.DepartmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DepartmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentCountAggregateOutputType> | number
        }
      }
    }
    Employee: {
      payload: Prisma.$EmployeePayload<ExtArgs>
      fields: Prisma.EmployeeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findFirst: {
          args: Prisma.EmployeeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findMany: {
          args: Prisma.EmployeeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        create: {
          args: Prisma.EmployeeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        createMany: {
          args: Prisma.EmployeeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        delete: {
          args: Prisma.EmployeeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        update: {
          args: Prisma.EmployeeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        deleteMany: {
          args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        upsert: {
          args: Prisma.EmployeeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        aggregate: {
          args: Prisma.EmployeeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployee>
        }
        groupBy: {
          args: Prisma.EmployeeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeCountAggregateOutputType> | number
        }
      }
    }
    Attendance: {
      payload: Prisma.$AttendancePayload<ExtArgs>
      fields: Prisma.AttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findFirst: {
          args: Prisma.AttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findMany: {
          args: Prisma.AttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        create: {
          args: Prisma.AttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        createMany: {
          args: Prisma.AttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        delete: {
          args: Prisma.AttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        update: {
          args: Prisma.AttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        deleteMany: {
          args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        upsert: {
          args: Prisma.AttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        aggregate: {
          args: Prisma.AttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendance>
        }
        groupBy: {
          args: Prisma.AttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCountAggregateOutputType> | number
        }
      }
    }
    AttendanceCorrection: {
      payload: Prisma.$AttendanceCorrectionPayload<ExtArgs>
      fields: Prisma.AttendanceCorrectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceCorrectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceCorrectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>
        }
        findFirst: {
          args: Prisma.AttendanceCorrectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceCorrectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>
        }
        findMany: {
          args: Prisma.AttendanceCorrectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>[]
        }
        create: {
          args: Prisma.AttendanceCorrectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>
        }
        createMany: {
          args: Prisma.AttendanceCorrectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceCorrectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>[]
        }
        delete: {
          args: Prisma.AttendanceCorrectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>
        }
        update: {
          args: Prisma.AttendanceCorrectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>
        }
        deleteMany: {
          args: Prisma.AttendanceCorrectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceCorrectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceCorrectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>[]
        }
        upsert: {
          args: Prisma.AttendanceCorrectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendanceCorrectionPayload>
        }
        aggregate: {
          args: Prisma.AttendanceCorrectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendanceCorrection>
        }
        groupBy: {
          args: Prisma.AttendanceCorrectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCorrectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceCorrectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCorrectionCountAggregateOutputType> | number
        }
      }
    }
    Payroll: {
      payload: Prisma.$PayrollPayload<ExtArgs>
      fields: Prisma.PayrollFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        findFirst: {
          args: Prisma.PayrollFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        findMany: {
          args: Prisma.PayrollFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        create: {
          args: Prisma.PayrollCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        createMany: {
          args: Prisma.PayrollCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        delete: {
          args: Prisma.PayrollDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        update: {
          args: Prisma.PayrollUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        deleteMany: {
          args: Prisma.PayrollDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        upsert: {
          args: Prisma.PayrollUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        aggregate: {
          args: Prisma.PayrollAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayroll>
        }
        groupBy: {
          args: Prisma.PayrollGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollCountAggregateOutputType> | number
        }
      }
    }
    PayrollAllowance: {
      payload: Prisma.$PayrollAllowancePayload<ExtArgs>
      fields: Prisma.PayrollAllowanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollAllowanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollAllowanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>
        }
        findFirst: {
          args: Prisma.PayrollAllowanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollAllowanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>
        }
        findMany: {
          args: Prisma.PayrollAllowanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>[]
        }
        create: {
          args: Prisma.PayrollAllowanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>
        }
        createMany: {
          args: Prisma.PayrollAllowanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollAllowanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>[]
        }
        delete: {
          args: Prisma.PayrollAllowanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>
        }
        update: {
          args: Prisma.PayrollAllowanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>
        }
        deleteMany: {
          args: Prisma.PayrollAllowanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollAllowanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollAllowanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>[]
        }
        upsert: {
          args: Prisma.PayrollAllowanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollAllowancePayload>
        }
        aggregate: {
          args: Prisma.PayrollAllowanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayrollAllowance>
        }
        groupBy: {
          args: Prisma.PayrollAllowanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollAllowanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollAllowanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollAllowanceCountAggregateOutputType> | number
        }
      }
    }
    PayrollDeduction: {
      payload: Prisma.$PayrollDeductionPayload<ExtArgs>
      fields: Prisma.PayrollDeductionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollDeductionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollDeductionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
        }
        findFirst: {
          args: Prisma.PayrollDeductionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollDeductionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
        }
        findMany: {
          args: Prisma.PayrollDeductionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>[]
        }
        create: {
          args: Prisma.PayrollDeductionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
        }
        createMany: {
          args: Prisma.PayrollDeductionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollDeductionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>[]
        }
        delete: {
          args: Prisma.PayrollDeductionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
        }
        update: {
          args: Prisma.PayrollDeductionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
        }
        deleteMany: {
          args: Prisma.PayrollDeductionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollDeductionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollDeductionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>[]
        }
        upsert: {
          args: Prisma.PayrollDeductionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
        }
        aggregate: {
          args: Prisma.PayrollDeductionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayrollDeduction>
        }
        groupBy: {
          args: Prisma.PayrollDeductionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollDeductionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollDeductionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollDeductionCountAggregateOutputType> | number
        }
      }
    }
    PayrollPayment: {
      payload: Prisma.$PayrollPaymentPayload<ExtArgs>
      fields: Prisma.PayrollPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>
        }
        findFirst: {
          args: Prisma.PayrollPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>
        }
        findMany: {
          args: Prisma.PayrollPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>[]
        }
        create: {
          args: Prisma.PayrollPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>
        }
        createMany: {
          args: Prisma.PayrollPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>[]
        }
        delete: {
          args: Prisma.PayrollPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>
        }
        update: {
          args: Prisma.PayrollPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>
        }
        deleteMany: {
          args: Prisma.PayrollPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>[]
        }
        upsert: {
          args: Prisma.PayrollPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPaymentPayload>
        }
        aggregate: {
          args: Prisma.PayrollPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayrollPayment>
        }
        groupBy: {
          args: Prisma.PayrollPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollPaymentCountAggregateOutputType> | number
        }
      }
    }
    SalaryHistory: {
      payload: Prisma.$SalaryHistoryPayload<ExtArgs>
      fields: Prisma.SalaryHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SalaryHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SalaryHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>
        }
        findFirst: {
          args: Prisma.SalaryHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SalaryHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>
        }
        findMany: {
          args: Prisma.SalaryHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>[]
        }
        create: {
          args: Prisma.SalaryHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>
        }
        createMany: {
          args: Prisma.SalaryHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SalaryHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>[]
        }
        delete: {
          args: Prisma.SalaryHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>
        }
        update: {
          args: Prisma.SalaryHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>
        }
        deleteMany: {
          args: Prisma.SalaryHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SalaryHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SalaryHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>[]
        }
        upsert: {
          args: Prisma.SalaryHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SalaryHistoryPayload>
        }
        aggregate: {
          args: Prisma.SalaryHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSalaryHistory>
        }
        groupBy: {
          args: Prisma.SalaryHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SalaryHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.SalaryHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SalaryHistoryCountAggregateOutputType> | number
        }
      }
    }
    LeaveRequest: {
      payload: Prisma.$LeaveRequestPayload<ExtArgs>
      fields: Prisma.LeaveRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        findFirst: {
          args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        findMany: {
          args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        create: {
          args: Prisma.LeaveRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        createMany: {
          args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        delete: {
          args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        update: {
          args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        deleteMany: {
          args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        upsert: {
          args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        aggregate: {
          args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaveRequest>
        }
        groupBy: {
          args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveRequestCountAggregateOutputType> | number
        }
      }
    }
    LeaveBalance: {
      payload: Prisma.$LeaveBalancePayload<ExtArgs>
      fields: Prisma.LeaveBalanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveBalanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        findFirst: {
          args: Prisma.LeaveBalanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveBalanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        findMany: {
          args: Prisma.LeaveBalanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
        }
        create: {
          args: Prisma.LeaveBalanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        createMany: {
          args: Prisma.LeaveBalanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveBalanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
        }
        delete: {
          args: Prisma.LeaveBalanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        update: {
          args: Prisma.LeaveBalanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        deleteMany: {
          args: Prisma.LeaveBalanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveBalanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveBalanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
        }
        upsert: {
          args: Prisma.LeaveBalanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
        }
        aggregate: {
          args: Prisma.LeaveBalanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaveBalance>
        }
        groupBy: {
          args: Prisma.LeaveBalanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveBalanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveBalanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveBalanceCountAggregateOutputType> | number
        }
      }
    }
    PublicHoliday: {
      payload: Prisma.$PublicHolidayPayload<ExtArgs>
      fields: Prisma.PublicHolidayFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PublicHolidayFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PublicHolidayFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
        }
        findFirst: {
          args: Prisma.PublicHolidayFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PublicHolidayFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
        }
        findMany: {
          args: Prisma.PublicHolidayFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>[]
        }
        create: {
          args: Prisma.PublicHolidayCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
        }
        createMany: {
          args: Prisma.PublicHolidayCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PublicHolidayCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>[]
        }
        delete: {
          args: Prisma.PublicHolidayDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
        }
        update: {
          args: Prisma.PublicHolidayUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
        }
        deleteMany: {
          args: Prisma.PublicHolidayDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PublicHolidayUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PublicHolidayUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>[]
        }
        upsert: {
          args: Prisma.PublicHolidayUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PublicHolidayPayload>
        }
        aggregate: {
          args: Prisma.PublicHolidayAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePublicHoliday>
        }
        groupBy: {
          args: Prisma.PublicHolidayGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PublicHolidayGroupByOutputType>[]
        }
        count: {
          args: Prisma.PublicHolidayCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PublicHolidayCountAggregateOutputType> | number
        }
      }
    }
    Lead: {
      payload: Prisma.$LeadPayload<ExtArgs>
      fields: Prisma.LeadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>
        }
        findFirst: {
          args: Prisma.LeadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>
        }
        findMany: {
          args: Prisma.LeadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>[]
        }
        create: {
          args: Prisma.LeadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>
        }
        createMany: {
          args: Prisma.LeadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>[]
        }
        delete: {
          args: Prisma.LeadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>
        }
        update: {
          args: Prisma.LeadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>
        }
        deleteMany: {
          args: Prisma.LeadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>[]
        }
        upsert: {
          args: Prisma.LeadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadPayload>
        }
        aggregate: {
          args: Prisma.LeadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLead>
        }
        groupBy: {
          args: Prisma.LeadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeadGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeadCountAggregateOutputType> | number
        }
      }
    }
    LeadImportBatch: {
      payload: Prisma.$LeadImportBatchPayload<ExtArgs>
      fields: Prisma.LeadImportBatchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeadImportBatchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeadImportBatchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>
        }
        findFirst: {
          args: Prisma.LeadImportBatchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeadImportBatchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>
        }
        findMany: {
          args: Prisma.LeadImportBatchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>[]
        }
        create: {
          args: Prisma.LeadImportBatchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>
        }
        createMany: {
          args: Prisma.LeadImportBatchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeadImportBatchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>[]
        }
        delete: {
          args: Prisma.LeadImportBatchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>
        }
        update: {
          args: Prisma.LeadImportBatchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>
        }
        deleteMany: {
          args: Prisma.LeadImportBatchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeadImportBatchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeadImportBatchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>[]
        }
        upsert: {
          args: Prisma.LeadImportBatchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportBatchPayload>
        }
        aggregate: {
          args: Prisma.LeadImportBatchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeadImportBatch>
        }
        groupBy: {
          args: Prisma.LeadImportBatchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeadImportBatchGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeadImportBatchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeadImportBatchCountAggregateOutputType> | number
        }
      }
    }
    LeadImportRow: {
      payload: Prisma.$LeadImportRowPayload<ExtArgs>
      fields: Prisma.LeadImportRowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeadImportRowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeadImportRowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>
        }
        findFirst: {
          args: Prisma.LeadImportRowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeadImportRowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>
        }
        findMany: {
          args: Prisma.LeadImportRowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>[]
        }
        create: {
          args: Prisma.LeadImportRowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>
        }
        createMany: {
          args: Prisma.LeadImportRowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeadImportRowCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>[]
        }
        delete: {
          args: Prisma.LeadImportRowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>
        }
        update: {
          args: Prisma.LeadImportRowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>
        }
        deleteMany: {
          args: Prisma.LeadImportRowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeadImportRowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeadImportRowUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>[]
        }
        upsert: {
          args: Prisma.LeadImportRowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeadImportRowPayload>
        }
        aggregate: {
          args: Prisma.LeadImportRowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeadImportRow>
        }
        groupBy: {
          args: Prisma.LeadImportRowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeadImportRowGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeadImportRowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeadImportRowCountAggregateOutputType> | number
        }
      }
    }
    Client: {
      payload: Prisma.$ClientPayload<ExtArgs>
      fields: Prisma.ClientFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ClientFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>
        }
        findFirst: {
          args: Prisma.ClientFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>
        }
        findMany: {
          args: Prisma.ClientFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>[]
        }
        create: {
          args: Prisma.ClientCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>
        }
        createMany: {
          args: Prisma.ClientCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>[]
        }
        delete: {
          args: Prisma.ClientDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>
        }
        update: {
          args: Prisma.ClientUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>
        }
        deleteMany: {
          args: Prisma.ClientDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ClientUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>[]
        }
        upsert: {
          args: Prisma.ClientUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ClientPayload>
        }
        aggregate: {
          args: Prisma.ClientAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateClient>
        }
        groupBy: {
          args: Prisma.ClientGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientGroupByOutputType>[]
        }
        count: {
          args: Prisma.ClientCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ClientCountAggregateOutputType> | number
        }
      }
    }
    ContactPerson: {
      payload: Prisma.$ContactPersonPayload<ExtArgs>
      fields: Prisma.ContactPersonFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContactPersonFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContactPersonFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>
        }
        findFirst: {
          args: Prisma.ContactPersonFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContactPersonFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>
        }
        findMany: {
          args: Prisma.ContactPersonFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>[]
        }
        create: {
          args: Prisma.ContactPersonCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>
        }
        createMany: {
          args: Prisma.ContactPersonCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContactPersonCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>[]
        }
        delete: {
          args: Prisma.ContactPersonDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>
        }
        update: {
          args: Prisma.ContactPersonUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>
        }
        deleteMany: {
          args: Prisma.ContactPersonDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContactPersonUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContactPersonUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>[]
        }
        upsert: {
          args: Prisma.ContactPersonUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPersonPayload>
        }
        aggregate: {
          args: Prisma.ContactPersonAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContactPerson>
        }
        groupBy: {
          args: Prisma.ContactPersonGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactPersonGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContactPersonCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactPersonCountAggregateOutputType> | number
        }
      }
    }
    Dealer: {
      payload: Prisma.$DealerPayload<ExtArgs>
      fields: Prisma.DealerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>
        }
        findFirst: {
          args: Prisma.DealerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>
        }
        findMany: {
          args: Prisma.DealerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>[]
        }
        create: {
          args: Prisma.DealerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>
        }
        createMany: {
          args: Prisma.DealerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>[]
        }
        delete: {
          args: Prisma.DealerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>
        }
        update: {
          args: Prisma.DealerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>
        }
        deleteMany: {
          args: Prisma.DealerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>[]
        }
        upsert: {
          args: Prisma.DealerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPayload>
        }
        aggregate: {
          args: Prisma.DealerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealer>
        }
        groupBy: {
          args: Prisma.DealerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerCountAggregateOutputType> | number
        }
      }
    }
    DealerReview: {
      payload: Prisma.$DealerReviewPayload<ExtArgs>
      fields: Prisma.DealerReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealerReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealerReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>
        }
        findFirst: {
          args: Prisma.DealerReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealerReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>
        }
        findMany: {
          args: Prisma.DealerReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>[]
        }
        create: {
          args: Prisma.DealerReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>
        }
        createMany: {
          args: Prisma.DealerReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealerReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>[]
        }
        delete: {
          args: Prisma.DealerReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>
        }
        update: {
          args: Prisma.DealerReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>
        }
        deleteMany: {
          args: Prisma.DealerReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealerReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealerReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>[]
        }
        upsert: {
          args: Prisma.DealerReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerReviewPayload>
        }
        aggregate: {
          args: Prisma.DealerReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealerReview>
        }
        groupBy: {
          args: Prisma.DealerReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealerReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerReviewCountAggregateOutputType> | number
        }
      }
    }
    Deal: {
      payload: Prisma.$DealPayload<ExtArgs>
      fields: Prisma.DealFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        findFirst: {
          args: Prisma.DealFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        findMany: {
          args: Prisma.DealFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>[]
        }
        create: {
          args: Prisma.DealCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        createMany: {
          args: Prisma.DealCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>[]
        }
        delete: {
          args: Prisma.DealDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        update: {
          args: Prisma.DealUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        deleteMany: {
          args: Prisma.DealDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>[]
        }
        upsert: {
          args: Prisma.DealUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        aggregate: {
          args: Prisma.DealAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeal>
        }
        groupBy: {
          args: Prisma.DealGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealCountAggregateOutputType> | number
        }
      }
    }
    DealAgent: {
      payload: Prisma.$DealAgentPayload<ExtArgs>
      fields: Prisma.DealAgentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealAgentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealAgentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>
        }
        findFirst: {
          args: Prisma.DealAgentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealAgentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>
        }
        findMany: {
          args: Prisma.DealAgentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>[]
        }
        create: {
          args: Prisma.DealAgentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>
        }
        createMany: {
          args: Prisma.DealAgentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealAgentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>[]
        }
        delete: {
          args: Prisma.DealAgentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>
        }
        update: {
          args: Prisma.DealAgentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>
        }
        deleteMany: {
          args: Prisma.DealAgentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealAgentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealAgentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>[]
        }
        upsert: {
          args: Prisma.DealAgentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealAgentPayload>
        }
        aggregate: {
          args: Prisma.DealAgentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealAgent>
        }
        groupBy: {
          args: Prisma.DealAgentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealAgentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealAgentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealAgentCountAggregateOutputType> | number
        }
      }
    }
    DealProperty: {
      payload: Prisma.$DealPropertyPayload<ExtArgs>
      fields: Prisma.DealPropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealPropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealPropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>
        }
        findFirst: {
          args: Prisma.DealPropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealPropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>
        }
        findMany: {
          args: Prisma.DealPropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>[]
        }
        create: {
          args: Prisma.DealPropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>
        }
        createMany: {
          args: Prisma.DealPropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealPropertyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>[]
        }
        delete: {
          args: Prisma.DealPropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>
        }
        update: {
          args: Prisma.DealPropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>
        }
        deleteMany: {
          args: Prisma.DealPropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealPropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealPropertyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>[]
        }
        upsert: {
          args: Prisma.DealPropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPropertyPayload>
        }
        aggregate: {
          args: Prisma.DealPropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealProperty>
        }
        groupBy: {
          args: Prisma.DealPropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealPropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealPropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealPropertyCountAggregateOutputType> | number
        }
      }
    }
    StageHistory: {
      payload: Prisma.$StageHistoryPayload<ExtArgs>
      fields: Prisma.StageHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StageHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StageHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>
        }
        findFirst: {
          args: Prisma.StageHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StageHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>
        }
        findMany: {
          args: Prisma.StageHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>[]
        }
        create: {
          args: Prisma.StageHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>
        }
        createMany: {
          args: Prisma.StageHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StageHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>[]
        }
        delete: {
          args: Prisma.StageHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>
        }
        update: {
          args: Prisma.StageHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>
        }
        deleteMany: {
          args: Prisma.StageHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StageHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StageHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>[]
        }
        upsert: {
          args: Prisma.StageHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StageHistoryPayload>
        }
        aggregate: {
          args: Prisma.StageHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStageHistory>
        }
        groupBy: {
          args: Prisma.StageHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StageHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.StageHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StageHistoryCountAggregateOutputType> | number
        }
      }
    }
    Communication: {
      payload: Prisma.$CommunicationPayload<ExtArgs>
      fields: Prisma.CommunicationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunicationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunicationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        findFirst: {
          args: Prisma.CommunicationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunicationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        findMany: {
          args: Prisma.CommunicationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
        }
        create: {
          args: Prisma.CommunicationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        createMany: {
          args: Prisma.CommunicationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunicationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
        }
        delete: {
          args: Prisma.CommunicationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        update: {
          args: Prisma.CommunicationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        deleteMany: {
          args: Prisma.CommunicationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunicationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunicationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
        }
        upsert: {
          args: Prisma.CommunicationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunicationPayload>
        }
        aggregate: {
          args: Prisma.CommunicationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunication>
        }
        groupBy: {
          args: Prisma.CommunicationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunicationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunicationCountAggregateOutputType> | number
        }
      }
    }
    CRMActivity: {
      payload: Prisma.$CRMActivityPayload<ExtArgs>
      fields: Prisma.CRMActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CRMActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CRMActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>
        }
        findFirst: {
          args: Prisma.CRMActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CRMActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>
        }
        findMany: {
          args: Prisma.CRMActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>[]
        }
        create: {
          args: Prisma.CRMActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>
        }
        createMany: {
          args: Prisma.CRMActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CRMActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>[]
        }
        delete: {
          args: Prisma.CRMActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>
        }
        update: {
          args: Prisma.CRMActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>
        }
        deleteMany: {
          args: Prisma.CRMActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CRMActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CRMActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>[]
        }
        upsert: {
          args: Prisma.CRMActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CRMActivityPayload>
        }
        aggregate: {
          args: Prisma.CRMActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCRMActivity>
        }
        groupBy: {
          args: Prisma.CRMActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CRMActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.CRMActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CRMActivityCountAggregateOutputType> | number
        }
      }
    }
    TransactionCategory: {
      payload: Prisma.$TransactionCategoryPayload<ExtArgs>
      fields: Prisma.TransactionCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
        }
        findFirst: {
          args: Prisma.TransactionCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
        }
        findMany: {
          args: Prisma.TransactionCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>[]
        }
        create: {
          args: Prisma.TransactionCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
        }
        createMany: {
          args: Prisma.TransactionCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>[]
        }
        delete: {
          args: Prisma.TransactionCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
        }
        update: {
          args: Prisma.TransactionCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
        }
        deleteMany: {
          args: Prisma.TransactionCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>[]
        }
        upsert: {
          args: Prisma.TransactionCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
        }
        aggregate: {
          args: Prisma.TransactionCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransactionCategory>
        }
        groupBy: {
          args: Prisma.TransactionCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCategoryCountAggregateOutputType> | number
        }
      }
    }
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>
      fields: Prisma.TransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
        }
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>
      fields: Prisma.PaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>
        }
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType> | number
        }
      }
    }
    TenantPayment: {
      payload: Prisma.$TenantPaymentPayload<ExtArgs>
      fields: Prisma.TenantPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>
        }
        findFirst: {
          args: Prisma.TenantPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>
        }
        findMany: {
          args: Prisma.TenantPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>[]
        }
        create: {
          args: Prisma.TenantPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>
        }
        createMany: {
          args: Prisma.TenantPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>[]
        }
        delete: {
          args: Prisma.TenantPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>
        }
        update: {
          args: Prisma.TenantPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>
        }
        deleteMany: {
          args: Prisma.TenantPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>[]
        }
        upsert: {
          args: Prisma.TenantPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPaymentPayload>
        }
        aggregate: {
          args: Prisma.TenantPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantPayment>
        }
        groupBy: {
          args: Prisma.TenantPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantPaymentCountAggregateOutputType> | number
        }
      }
    }
    MaintenanceTicket: {
      payload: Prisma.$MaintenanceTicketPayload<ExtArgs>
      fields: Prisma.MaintenanceTicketFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MaintenanceTicketFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MaintenanceTicketFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
        }
        findFirst: {
          args: Prisma.MaintenanceTicketFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MaintenanceTicketFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
        }
        findMany: {
          args: Prisma.MaintenanceTicketFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>[]
        }
        create: {
          args: Prisma.MaintenanceTicketCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
        }
        createMany: {
          args: Prisma.MaintenanceTicketCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MaintenanceTicketCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>[]
        }
        delete: {
          args: Prisma.MaintenanceTicketDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
        }
        update: {
          args: Prisma.MaintenanceTicketUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
        }
        deleteMany: {
          args: Prisma.MaintenanceTicketDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MaintenanceTicketUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MaintenanceTicketUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>[]
        }
        upsert: {
          args: Prisma.MaintenanceTicketUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
        }
        aggregate: {
          args: Prisma.MaintenanceTicketAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenanceTicket>
        }
        groupBy: {
          args: Prisma.MaintenanceTicketGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceTicketGroupByOutputType>[]
        }
        count: {
          args: Prisma.MaintenanceTicketCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceTicketCountAggregateOutputType> | number
        }
      }
    }
    MaintenanceActivity: {
      payload: Prisma.$MaintenanceActivityPayload<ExtArgs>
      fields: Prisma.MaintenanceActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MaintenanceActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MaintenanceActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>
        }
        findFirst: {
          args: Prisma.MaintenanceActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MaintenanceActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>
        }
        findMany: {
          args: Prisma.MaintenanceActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>[]
        }
        create: {
          args: Prisma.MaintenanceActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>
        }
        createMany: {
          args: Prisma.MaintenanceActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MaintenanceActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>[]
        }
        delete: {
          args: Prisma.MaintenanceActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>
        }
        update: {
          args: Prisma.MaintenanceActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>
        }
        deleteMany: {
          args: Prisma.MaintenanceActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MaintenanceActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MaintenanceActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>[]
        }
        upsert: {
          args: Prisma.MaintenanceActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceActivityPayload>
        }
        aggregate: {
          args: Prisma.MaintenanceActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenanceActivity>
        }
        groupBy: {
          args: Prisma.MaintenanceActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.MaintenanceActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceActivityCountAggregateOutputType> | number
        }
      }
    }
    NoticeToVacate: {
      payload: Prisma.$NoticeToVacatePayload<ExtArgs>
      fields: Prisma.NoticeToVacateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NoticeToVacateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NoticeToVacateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>
        }
        findFirst: {
          args: Prisma.NoticeToVacateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NoticeToVacateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>
        }
        findMany: {
          args: Prisma.NoticeToVacateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>[]
        }
        create: {
          args: Prisma.NoticeToVacateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>
        }
        createMany: {
          args: Prisma.NoticeToVacateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NoticeToVacateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>[]
        }
        delete: {
          args: Prisma.NoticeToVacateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>
        }
        update: {
          args: Prisma.NoticeToVacateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>
        }
        deleteMany: {
          args: Prisma.NoticeToVacateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NoticeToVacateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NoticeToVacateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>[]
        }
        upsert: {
          args: Prisma.NoticeToVacateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoticeToVacatePayload>
        }
        aggregate: {
          args: Prisma.NoticeToVacateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNoticeToVacate>
        }
        groupBy: {
          args: Prisma.NoticeToVacateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoticeToVacateGroupByOutputType>[]
        }
        count: {
          args: Prisma.NoticeToVacateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoticeToVacateCountAggregateOutputType> | number
        }
      }
    }
    RentReminder: {
      payload: Prisma.$RentReminderPayload<ExtArgs>
      fields: Prisma.RentReminderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentReminderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentReminderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>
        }
        findFirst: {
          args: Prisma.RentReminderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentReminderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>
        }
        findMany: {
          args: Prisma.RentReminderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>[]
        }
        create: {
          args: Prisma.RentReminderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>
        }
        createMany: {
          args: Prisma.RentReminderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentReminderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>[]
        }
        delete: {
          args: Prisma.RentReminderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>
        }
        update: {
          args: Prisma.RentReminderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>
        }
        deleteMany: {
          args: Prisma.RentReminderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentReminderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentReminderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>[]
        }
        upsert: {
          args: Prisma.RentReminderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentReminderPayload>
        }
        aggregate: {
          args: Prisma.RentReminderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentReminder>
        }
        groupBy: {
          args: Prisma.RentReminderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentReminderGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentReminderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentReminderCountAggregateOutputType> | number
        }
      }
    }
    TenantLedger: {
      payload: Prisma.$TenantLedgerPayload<ExtArgs>
      fields: Prisma.TenantLedgerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantLedgerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantLedgerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>
        }
        findFirst: {
          args: Prisma.TenantLedgerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantLedgerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>
        }
        findMany: {
          args: Prisma.TenantLedgerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>[]
        }
        create: {
          args: Prisma.TenantLedgerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>
        }
        createMany: {
          args: Prisma.TenantLedgerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantLedgerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>[]
        }
        delete: {
          args: Prisma.TenantLedgerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>
        }
        update: {
          args: Prisma.TenantLedgerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>
        }
        deleteMany: {
          args: Prisma.TenantLedgerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantLedgerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantLedgerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>[]
        }
        upsert: {
          args: Prisma.TenantLedgerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLedgerPayload>
        }
        aggregate: {
          args: Prisma.TenantLedgerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantLedger>
        }
        groupBy: {
          args: Prisma.TenantLedgerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantLedgerGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantLedgerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantLedgerCountAggregateOutputType> | number
        }
      }
    }
    Receipt: {
      payload: Prisma.$ReceiptPayload<ExtArgs>
      fields: Prisma.ReceiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReceiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReceiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        findFirst: {
          args: Prisma.ReceiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReceiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        findMany: {
          args: Prisma.ReceiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        create: {
          args: Prisma.ReceiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        createMany: {
          args: Prisma.ReceiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReceiptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        delete: {
          args: Prisma.ReceiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        update: {
          args: Prisma.ReceiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        deleteMany: {
          args: Prisma.ReceiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReceiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReceiptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>[]
        }
        upsert: {
          args: Prisma.ReceiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReceiptPayload>
        }
        aggregate: {
          args: Prisma.ReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceipt>
        }
        groupBy: {
          args: Prisma.ReceiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReceiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptCountAggregateOutputType> | number
        }
      }
    }
    Announcement: {
      payload: Prisma.$AnnouncementPayload<ExtArgs>
      fields: Prisma.AnnouncementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findFirst: {
          args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findMany: {
          args: Prisma.AnnouncementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        create: {
          args: Prisma.AnnouncementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        createMany: {
          args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        delete: {
          args: Prisma.AnnouncementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        update: {
          args: Prisma.AnnouncementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        deleteMany: {
          args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        upsert: {
          args: Prisma.AnnouncementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        aggregate: {
          args: Prisma.AnnouncementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncement>
        }
        groupBy: {
          args: Prisma.AnnouncementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnnouncementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementCountAggregateOutputType> | number
        }
      }
    }
    RevenueSummary: {
      payload: Prisma.$RevenueSummaryPayload<ExtArgs>
      fields: Prisma.RevenueSummaryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RevenueSummaryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RevenueSummaryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>
        }
        findFirst: {
          args: Prisma.RevenueSummaryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RevenueSummaryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>
        }
        findMany: {
          args: Prisma.RevenueSummaryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>[]
        }
        create: {
          args: Prisma.RevenueSummaryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>
        }
        createMany: {
          args: Prisma.RevenueSummaryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RevenueSummaryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>[]
        }
        delete: {
          args: Prisma.RevenueSummaryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>
        }
        update: {
          args: Prisma.RevenueSummaryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>
        }
        deleteMany: {
          args: Prisma.RevenueSummaryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RevenueSummaryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RevenueSummaryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>[]
        }
        upsert: {
          args: Prisma.RevenueSummaryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RevenueSummaryPayload>
        }
        aggregate: {
          args: Prisma.RevenueSummaryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRevenueSummary>
        }
        groupBy: {
          args: Prisma.RevenueSummaryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RevenueSummaryGroupByOutputType>[]
        }
        count: {
          args: Prisma.RevenueSummaryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RevenueSummaryCountAggregateOutputType> | number
        }
      }
    }
    ExpenseSummary: {
      payload: Prisma.$ExpenseSummaryPayload<ExtArgs>
      fields: Prisma.ExpenseSummaryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExpenseSummaryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExpenseSummaryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>
        }
        findFirst: {
          args: Prisma.ExpenseSummaryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExpenseSummaryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>
        }
        findMany: {
          args: Prisma.ExpenseSummaryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>[]
        }
        create: {
          args: Prisma.ExpenseSummaryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>
        }
        createMany: {
          args: Prisma.ExpenseSummaryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExpenseSummaryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>[]
        }
        delete: {
          args: Prisma.ExpenseSummaryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>
        }
        update: {
          args: Prisma.ExpenseSummaryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>
        }
        deleteMany: {
          args: Prisma.ExpenseSummaryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExpenseSummaryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExpenseSummaryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>[]
        }
        upsert: {
          args: Prisma.ExpenseSummaryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpenseSummaryPayload>
        }
        aggregate: {
          args: Prisma.ExpenseSummaryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpenseSummary>
        }
        groupBy: {
          args: Prisma.ExpenseSummaryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseSummaryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExpenseSummaryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseSummaryCountAggregateOutputType> | number
        }
      }
    }
    Voucher: {
      payload: Prisma.$VoucherPayload<ExtArgs>
      fields: Prisma.VoucherFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VoucherFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>
        }
        findFirst: {
          args: Prisma.VoucherFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>
        }
        findMany: {
          args: Prisma.VoucherFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>[]
        }
        create: {
          args: Prisma.VoucherCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>
        }
        createMany: {
          args: Prisma.VoucherCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>[]
        }
        delete: {
          args: Prisma.VoucherDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>
        }
        update: {
          args: Prisma.VoucherUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>
        }
        deleteMany: {
          args: Prisma.VoucherDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VoucherUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>[]
        }
        upsert: {
          args: Prisma.VoucherUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherPayload>
        }
        aggregate: {
          args: Prisma.VoucherAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVoucher>
        }
        groupBy: {
          args: Prisma.VoucherGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VoucherGroupByOutputType>[]
        }
        count: {
          args: Prisma.VoucherCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VoucherCountAggregateOutputType> | number
        }
      }
    }
    VoucherLine: {
      payload: Prisma.$VoucherLinePayload<ExtArgs>
      fields: Prisma.VoucherLineFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VoucherLineFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VoucherLineFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>
        }
        findFirst: {
          args: Prisma.VoucherLineFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VoucherLineFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>
        }
        findMany: {
          args: Prisma.VoucherLineFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>[]
        }
        create: {
          args: Prisma.VoucherLineCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>
        }
        createMany: {
          args: Prisma.VoucherLineCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VoucherLineCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>[]
        }
        delete: {
          args: Prisma.VoucherLineDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>
        }
        update: {
          args: Prisma.VoucherLineUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>
        }
        deleteMany: {
          args: Prisma.VoucherLineDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VoucherLineUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VoucherLineUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>[]
        }
        upsert: {
          args: Prisma.VoucherLineUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VoucherLinePayload>
        }
        aggregate: {
          args: Prisma.VoucherLineAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVoucherLine>
        }
        groupBy: {
          args: Prisma.VoucherLineGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VoucherLineGroupByOutputType>[]
        }
        count: {
          args: Prisma.VoucherLineCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VoucherLineCountAggregateOutputType> | number
        }
      }
    }
    Commission: {
      payload: Prisma.$CommissionPayload<ExtArgs>
      fields: Prisma.CommissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        findFirst: {
          args: Prisma.CommissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        findMany: {
          args: Prisma.CommissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>[]
        }
        create: {
          args: Prisma.CommissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        createMany: {
          args: Prisma.CommissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>[]
        }
        delete: {
          args: Prisma.CommissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        update: {
          args: Prisma.CommissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        deleteMany: {
          args: Prisma.CommissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>[]
        }
        upsert: {
          args: Prisma.CommissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommissionPayload>
        }
        aggregate: {
          args: Prisma.CommissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommission>
        }
        groupBy: {
          args: Prisma.CommissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommissionCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    JournalEntry: {
      payload: Prisma.$JournalEntryPayload<ExtArgs>
      fields: Prisma.JournalEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>
        }
        findFirst: {
          args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>
        }
        findMany: {
          args: Prisma.JournalEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
        }
        create: {
          args: Prisma.JournalEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>
        }
        createMany: {
          args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
        }
        delete: {
          args: Prisma.JournalEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>
        }
        update: {
          args: Prisma.JournalEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>
        }
        deleteMany: {
          args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.JournalEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
        }
        upsert: {
          args: Prisma.JournalEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalEntryPayload>
        }
        aggregate: {
          args: Prisma.JournalEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJournalEntry>
        }
        groupBy: {
          args: Prisma.JournalEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JournalEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.JournalEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JournalEntryCountAggregateOutputType> | number
        }
      }
    }
    JournalLine: {
      payload: Prisma.$JournalLinePayload<ExtArgs>
      fields: Prisma.JournalLineFieldRefs
      operations: {
        findUnique: {
          args: Prisma.JournalLineFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.JournalLineFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>
        }
        findFirst: {
          args: Prisma.JournalLineFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.JournalLineFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>
        }
        findMany: {
          args: Prisma.JournalLineFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
        }
        create: {
          args: Prisma.JournalLineCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>
        }
        createMany: {
          args: Prisma.JournalLineCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.JournalLineCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
        }
        delete: {
          args: Prisma.JournalLineDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>
        }
        update: {
          args: Prisma.JournalLineUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>
        }
        deleteMany: {
          args: Prisma.JournalLineDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.JournalLineUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.JournalLineUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
        }
        upsert: {
          args: Prisma.JournalLineUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JournalLinePayload>
        }
        aggregate: {
          args: Prisma.JournalLineAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJournalLine>
        }
        groupBy: {
          args: Prisma.JournalLineGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JournalLineGroupByOutputType>[]
        }
        count: {
          args: Prisma.JournalLineCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JournalLineCountAggregateOutputType> | number
        }
      }
    }
    LedgerEntry: {
      payload: Prisma.$LedgerEntryPayload<ExtArgs>
      fields: Prisma.LedgerEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
        }
        findFirst: {
          args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
        }
        findMany: {
          args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
        }
        create: {
          args: Prisma.LedgerEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
        }
        createMany: {
          args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
        }
        delete: {
          args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
        }
        update: {
          args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
        }
        deleteMany: {
          args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LedgerEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
        }
        upsert: {
          args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
        }
        aggregate: {
          args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLedgerEntry>
        }
        groupBy: {
          args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LedgerEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.LedgerEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LedgerEntryCountAggregateOutputType> | number
        }
      }
    }
    PropertyExpense: {
      payload: Prisma.$PropertyExpensePayload<ExtArgs>
      fields: Prisma.PropertyExpenseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PropertyExpenseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PropertyExpenseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>
        }
        findFirst: {
          args: Prisma.PropertyExpenseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PropertyExpenseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>
        }
        findMany: {
          args: Prisma.PropertyExpenseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>[]
        }
        create: {
          args: Prisma.PropertyExpenseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>
        }
        createMany: {
          args: Prisma.PropertyExpenseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PropertyExpenseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>[]
        }
        delete: {
          args: Prisma.PropertyExpenseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>
        }
        update: {
          args: Prisma.PropertyExpenseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>
        }
        deleteMany: {
          args: Prisma.PropertyExpenseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PropertyExpenseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PropertyExpenseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>[]
        }
        upsert: {
          args: Prisma.PropertyExpenseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PropertyExpensePayload>
        }
        aggregate: {
          args: Prisma.PropertyExpenseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePropertyExpense>
        }
        groupBy: {
          args: Prisma.PropertyExpenseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyExpenseGroupByOutputType>[]
        }
        count: {
          args: Prisma.PropertyExpenseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyExpenseCountAggregateOutputType> | number
        }
      }
    }
    Tenancy: {
      payload: Prisma.$TenancyPayload<ExtArgs>
      fields: Prisma.TenancyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenancyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenancyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>
        }
        findFirst: {
          args: Prisma.TenancyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenancyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>
        }
        findMany: {
          args: Prisma.TenancyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>[]
        }
        create: {
          args: Prisma.TenancyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>
        }
        createMany: {
          args: Prisma.TenancyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenancyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>[]
        }
        delete: {
          args: Prisma.TenancyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>
        }
        update: {
          args: Prisma.TenancyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>
        }
        deleteMany: {
          args: Prisma.TenancyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenancyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenancyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>[]
        }
        upsert: {
          args: Prisma.TenancyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenancyPayload>
        }
        aggregate: {
          args: Prisma.TenancyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenancy>
        }
        groupBy: {
          args: Prisma.TenancyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenancyGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenancyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenancyCountAggregateOutputType> | number
        }
      }
    }
    MaintenanceRequest: {
      payload: Prisma.$MaintenanceRequestPayload<ExtArgs>
      fields: Prisma.MaintenanceRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MaintenanceRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
        }
        findFirst: {
          args: Prisma.MaintenanceRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
        }
        findMany: {
          args: Prisma.MaintenanceRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
        }
        create: {
          args: Prisma.MaintenanceRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
        }
        createMany: {
          args: Prisma.MaintenanceRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
        }
        delete: {
          args: Prisma.MaintenanceRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
        }
        update: {
          args: Prisma.MaintenanceRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
        }
        deleteMany: {
          args: Prisma.MaintenanceRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MaintenanceRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
        }
        upsert: {
          args: Prisma.MaintenanceRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
        }
        aggregate: {
          args: Prisma.MaintenanceRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenanceRequest>
        }
        groupBy: {
          args: Prisma.MaintenanceRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.MaintenanceRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceRequestCountAggregateOutputType> | number
        }
      }
    }
    FinanceLedger: {
      payload: Prisma.$FinanceLedgerPayload<ExtArgs>
      fields: Prisma.FinanceLedgerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinanceLedgerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinanceLedgerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>
        }
        findFirst: {
          args: Prisma.FinanceLedgerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinanceLedgerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>
        }
        findMany: {
          args: Prisma.FinanceLedgerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>[]
        }
        create: {
          args: Prisma.FinanceLedgerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>
        }
        createMany: {
          args: Prisma.FinanceLedgerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinanceLedgerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>[]
        }
        delete: {
          args: Prisma.FinanceLedgerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>
        }
        update: {
          args: Prisma.FinanceLedgerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>
        }
        deleteMany: {
          args: Prisma.FinanceLedgerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinanceLedgerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinanceLedgerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>[]
        }
        upsert: {
          args: Prisma.FinanceLedgerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinanceLedgerPayload>
        }
        aggregate: {
          args: Prisma.FinanceLedgerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinanceLedger>
        }
        groupBy: {
          args: Prisma.FinanceLedgerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceLedgerGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinanceLedgerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinanceLedgerCountAggregateOutputType> | number
        }
      }
    }
    Attachment: {
      payload: Prisma.$AttachmentPayload<ExtArgs>
      fields: Prisma.AttachmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>
        }
        findFirst: {
          args: Prisma.AttachmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>
        }
        findMany: {
          args: Prisma.AttachmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
        }
        create: {
          args: Prisma.AttachmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>
        }
        createMany: {
          args: Prisma.AttachmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
        }
        delete: {
          args: Prisma.AttachmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>
        }
        update: {
          args: Prisma.AttachmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>
        }
        deleteMany: {
          args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
        }
        upsert: {
          args: Prisma.AttachmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttachmentPayload>
        }
        aggregate: {
          args: Prisma.AttachmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttachment>
        }
        groupBy: {
          args: Prisma.AttachmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttachmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttachmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttachmentCountAggregateOutputType> | number
        }
      }
    }
    DropdownCategory: {
      payload: Prisma.$DropdownCategoryPayload<ExtArgs>
      fields: Prisma.DropdownCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DropdownCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DropdownCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>
        }
        findFirst: {
          args: Prisma.DropdownCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DropdownCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>
        }
        findMany: {
          args: Prisma.DropdownCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>[]
        }
        create: {
          args: Prisma.DropdownCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>
        }
        createMany: {
          args: Prisma.DropdownCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DropdownCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>[]
        }
        delete: {
          args: Prisma.DropdownCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>
        }
        update: {
          args: Prisma.DropdownCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>
        }
        deleteMany: {
          args: Prisma.DropdownCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DropdownCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DropdownCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>[]
        }
        upsert: {
          args: Prisma.DropdownCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownCategoryPayload>
        }
        aggregate: {
          args: Prisma.DropdownCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDropdownCategory>
        }
        groupBy: {
          args: Prisma.DropdownCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DropdownCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.DropdownCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DropdownCategoryCountAggregateOutputType> | number
        }
      }
    }
    DropdownOption: {
      payload: Prisma.$DropdownOptionPayload<ExtArgs>
      fields: Prisma.DropdownOptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DropdownOptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DropdownOptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
        }
        findFirst: {
          args: Prisma.DropdownOptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DropdownOptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
        }
        findMany: {
          args: Prisma.DropdownOptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>[]
        }
        create: {
          args: Prisma.DropdownOptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
        }
        createMany: {
          args: Prisma.DropdownOptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DropdownOptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>[]
        }
        delete: {
          args: Prisma.DropdownOptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
        }
        update: {
          args: Prisma.DropdownOptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
        }
        deleteMany: {
          args: Prisma.DropdownOptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DropdownOptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DropdownOptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>[]
        }
        upsert: {
          args: Prisma.DropdownOptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DropdownOptionPayload>
        }
        aggregate: {
          args: Prisma.DropdownOptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDropdownOption>
        }
        groupBy: {
          args: Prisma.DropdownOptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DropdownOptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DropdownOptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DropdownOptionCountAggregateOutputType> | number
        }
      }
    }
    Amenity: {
      payload: Prisma.$AmenityPayload<ExtArgs>
      fields: Prisma.AmenityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AmenityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        findFirst: {
          args: Prisma.AmenityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        findMany: {
          args: Prisma.AmenityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        create: {
          args: Prisma.AmenityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        createMany: {
          args: Prisma.AmenityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        delete: {
          args: Prisma.AmenityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        update: {
          args: Prisma.AmenityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        deleteMany: {
          args: Prisma.AmenityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AmenityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>[]
        }
        upsert: {
          args: Prisma.AmenityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AmenityPayload>
        }
        aggregate: {
          args: Prisma.AmenityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAmenity>
        }
        groupBy: {
          args: Prisma.AmenityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AmenityGroupByOutputType>[]
        }
        count: {
          args: Prisma.AmenityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AmenityCountAggregateOutputType> | number
        }
      }
    }
    DealerPayment: {
      payload: Prisma.$DealerPaymentPayload<ExtArgs>
      fields: Prisma.DealerPaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealerPaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealerPaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>
        }
        findFirst: {
          args: Prisma.DealerPaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealerPaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>
        }
        findMany: {
          args: Prisma.DealerPaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>[]
        }
        create: {
          args: Prisma.DealerPaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>
        }
        createMany: {
          args: Prisma.DealerPaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealerPaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>[]
        }
        delete: {
          args: Prisma.DealerPaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>
        }
        update: {
          args: Prisma.DealerPaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>
        }
        deleteMany: {
          args: Prisma.DealerPaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealerPaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealerPaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>[]
        }
        upsert: {
          args: Prisma.DealerPaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerPaymentPayload>
        }
        aggregate: {
          args: Prisma.DealerPaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealerPayment>
        }
        groupBy: {
          args: Prisma.DealerPaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerPaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealerPaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerPaymentCountAggregateOutputType> | number
        }
      }
    }
    PaymentPlan: {
      payload: Prisma.$PaymentPlanPayload<ExtArgs>
      fields: Prisma.PaymentPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        findFirst: {
          args: Prisma.PaymentPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        findMany: {
          args: Prisma.PaymentPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
        }
        create: {
          args: Prisma.PaymentPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        createMany: {
          args: Prisma.PaymentPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
        }
        delete: {
          args: Prisma.PaymentPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        update: {
          args: Prisma.PaymentPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        deleteMany: {
          args: Prisma.PaymentPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>[]
        }
        upsert: {
          args: Prisma.PaymentPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPlanPayload>
        }
        aggregate: {
          args: Prisma.PaymentPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentPlan>
        }
        groupBy: {
          args: Prisma.PaymentPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentPlanCountAggregateOutputType> | number
        }
      }
    }
    DealInstallment: {
      payload: Prisma.$DealInstallmentPayload<ExtArgs>
      fields: Prisma.DealInstallmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealInstallmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealInstallmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>
        }
        findFirst: {
          args: Prisma.DealInstallmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealInstallmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>
        }
        findMany: {
          args: Prisma.DealInstallmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>[]
        }
        create: {
          args: Prisma.DealInstallmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>
        }
        createMany: {
          args: Prisma.DealInstallmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealInstallmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>[]
        }
        delete: {
          args: Prisma.DealInstallmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>
        }
        update: {
          args: Prisma.DealInstallmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>
        }
        deleteMany: {
          args: Prisma.DealInstallmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealInstallmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealInstallmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>[]
        }
        upsert: {
          args: Prisma.DealInstallmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealInstallmentPayload>
        }
        aggregate: {
          args: Prisma.DealInstallmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealInstallment>
        }
        groupBy: {
          args: Prisma.DealInstallmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealInstallmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealInstallmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealInstallmentCountAggregateOutputType> | number
        }
      }
    }
    DealerLedger: {
      payload: Prisma.$DealerLedgerPayload<ExtArgs>
      fields: Prisma.DealerLedgerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealerLedgerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealerLedgerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>
        }
        findFirst: {
          args: Prisma.DealerLedgerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealerLedgerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>
        }
        findMany: {
          args: Prisma.DealerLedgerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>[]
        }
        create: {
          args: Prisma.DealerLedgerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>
        }
        createMany: {
          args: Prisma.DealerLedgerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealerLedgerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>[]
        }
        delete: {
          args: Prisma.DealerLedgerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>
        }
        update: {
          args: Prisma.DealerLedgerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>
        }
        deleteMany: {
          args: Prisma.DealerLedgerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealerLedgerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealerLedgerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>[]
        }
        upsert: {
          args: Prisma.DealerLedgerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealerLedgerPayload>
        }
        aggregate: {
          args: Prisma.DealerLedgerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealerLedger>
        }
        groupBy: {
          args: Prisma.DealerLedgerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerLedgerGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealerLedgerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealerLedgerCountAggregateOutputType> | number
        }
      }
    }
    AccountAlias: {
      payload: Prisma.$AccountAliasPayload<ExtArgs>
      fields: Prisma.AccountAliasFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountAliasFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountAliasFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>
        }
        findFirst: {
          args: Prisma.AccountAliasFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountAliasFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>
        }
        findMany: {
          args: Prisma.AccountAliasFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>[]
        }
        create: {
          args: Prisma.AccountAliasCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>
        }
        createMany: {
          args: Prisma.AccountAliasCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountAliasCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>[]
        }
        delete: {
          args: Prisma.AccountAliasDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>
        }
        update: {
          args: Prisma.AccountAliasUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>
        }
        deleteMany: {
          args: Prisma.AccountAliasDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountAliasUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountAliasUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>[]
        }
        upsert: {
          args: Prisma.AccountAliasUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountAliasPayload>
        }
        aggregate: {
          args: Prisma.AccountAliasAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccountAlias>
        }
        groupBy: {
          args: Prisma.AccountAliasGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountAliasGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountAliasCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountAliasCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    DealReceipt: {
      payload: Prisma.$DealReceiptPayload<ExtArgs>
      fields: Prisma.DealReceiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealReceiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealReceiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>
        }
        findFirst: {
          args: Prisma.DealReceiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealReceiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>
        }
        findMany: {
          args: Prisma.DealReceiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>[]
        }
        create: {
          args: Prisma.DealReceiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>
        }
        createMany: {
          args: Prisma.DealReceiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealReceiptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>[]
        }
        delete: {
          args: Prisma.DealReceiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>
        }
        update: {
          args: Prisma.DealReceiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>
        }
        deleteMany: {
          args: Prisma.DealReceiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealReceiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealReceiptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>[]
        }
        upsert: {
          args: Prisma.DealReceiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptPayload>
        }
        aggregate: {
          args: Prisma.DealReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealReceipt>
        }
        groupBy: {
          args: Prisma.DealReceiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealReceiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealReceiptCountAggregateOutputType> | number
        }
      }
    }
    DealReceiptAllocation: {
      payload: Prisma.$DealReceiptAllocationPayload<ExtArgs>
      fields: Prisma.DealReceiptAllocationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealReceiptAllocationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealReceiptAllocationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>
        }
        findFirst: {
          args: Prisma.DealReceiptAllocationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealReceiptAllocationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>
        }
        findMany: {
          args: Prisma.DealReceiptAllocationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>[]
        }
        create: {
          args: Prisma.DealReceiptAllocationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>
        }
        createMany: {
          args: Prisma.DealReceiptAllocationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealReceiptAllocationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>[]
        }
        delete: {
          args: Prisma.DealReceiptAllocationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>
        }
        update: {
          args: Prisma.DealReceiptAllocationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>
        }
        deleteMany: {
          args: Prisma.DealReceiptAllocationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealReceiptAllocationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealReceiptAllocationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>[]
        }
        upsert: {
          args: Prisma.DealReceiptAllocationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealReceiptAllocationPayload>
        }
        aggregate: {
          args: Prisma.DealReceiptAllocationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDealReceiptAllocation>
        }
        groupBy: {
          args: Prisma.DealReceiptAllocationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealReceiptAllocationGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealReceiptAllocationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealReceiptAllocationCountAggregateOutputType> | number
        }
      }
    }
    RefreshToken: {
      payload: Prisma.$RefreshTokenPayload<ExtArgs>
      fields: Prisma.RefreshTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findFirst: {
          args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        findMany: {
          args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        create: {
          args: Prisma.RefreshTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        createMany: {
          args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        delete: {
          args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        update: {
          args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        deleteMany: {
          args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
        }
        upsert: {
          args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
        }
        aggregate: {
          args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefreshToken>
        }
        groupBy: {
          args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefreshTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefreshTokenCountAggregateOutputType> | number
        }
      }
    }
    CsrfToken: {
      payload: Prisma.$CsrfTokenPayload<ExtArgs>
      fields: Prisma.CsrfTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CsrfTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CsrfTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>
        }
        findFirst: {
          args: Prisma.CsrfTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CsrfTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>
        }
        findMany: {
          args: Prisma.CsrfTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>[]
        }
        create: {
          args: Prisma.CsrfTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>
        }
        createMany: {
          args: Prisma.CsrfTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CsrfTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>[]
        }
        delete: {
          args: Prisma.CsrfTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>
        }
        update: {
          args: Prisma.CsrfTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>
        }
        deleteMany: {
          args: Prisma.CsrfTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CsrfTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CsrfTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>[]
        }
        upsert: {
          args: Prisma.CsrfTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CsrfTokenPayload>
        }
        aggregate: {
          args: Prisma.CsrfTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCsrfToken>
        }
        groupBy: {
          args: Prisma.CsrfTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CsrfTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.CsrfTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CsrfTokenCountAggregateOutputType> | number
        }
      }
    }
    DeletedRecord: {
      payload: Prisma.$DeletedRecordPayload<ExtArgs>
      fields: Prisma.DeletedRecordFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DeletedRecordFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DeletedRecordFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>
        }
        findFirst: {
          args: Prisma.DeletedRecordFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DeletedRecordFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>
        }
        findMany: {
          args: Prisma.DeletedRecordFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>[]
        }
        create: {
          args: Prisma.DeletedRecordCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>
        }
        createMany: {
          args: Prisma.DeletedRecordCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DeletedRecordCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>[]
        }
        delete: {
          args: Prisma.DeletedRecordDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>
        }
        update: {
          args: Prisma.DeletedRecordUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>
        }
        deleteMany: {
          args: Prisma.DeletedRecordDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DeletedRecordUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DeletedRecordUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>[]
        }
        upsert: {
          args: Prisma.DeletedRecordUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeletedRecordPayload>
        }
        aggregate: {
          args: Prisma.DeletedRecordAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeletedRecord>
        }
        groupBy: {
          args: Prisma.DeletedRecordGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeletedRecordGroupByOutputType>[]
        }
        count: {
          args: Prisma.DeletedRecordCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeletedRecordCountAggregateOutputType> | number
        }
      }
    }
    Sequence: {
      payload: Prisma.$SequencePayload<ExtArgs>
      fields: Prisma.SequenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SequenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SequenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>
        }
        findFirst: {
          args: Prisma.SequenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SequenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>
        }
        findMany: {
          args: Prisma.SequenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>[]
        }
        create: {
          args: Prisma.SequenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>
        }
        createMany: {
          args: Prisma.SequenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SequenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>[]
        }
        delete: {
          args: Prisma.SequenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>
        }
        update: {
          args: Prisma.SequenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>
        }
        deleteMany: {
          args: Prisma.SequenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SequenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SequenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>[]
        }
        upsert: {
          args: Prisma.SequenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SequencePayload>
        }
        aggregate: {
          args: Prisma.SequenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSequence>
        }
        groupBy: {
          args: Prisma.SequenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SequenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.SequenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SequenceCountAggregateOutputType> | number
        }
      }
    }
    EntityAccountBinding: {
      payload: Prisma.$EntityAccountBindingPayload<ExtArgs>
      fields: Prisma.EntityAccountBindingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EntityAccountBindingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EntityAccountBindingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>
        }
        findFirst: {
          args: Prisma.EntityAccountBindingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EntityAccountBindingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>
        }
        findMany: {
          args: Prisma.EntityAccountBindingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>[]
        }
        create: {
          args: Prisma.EntityAccountBindingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>
        }
        createMany: {
          args: Prisma.EntityAccountBindingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EntityAccountBindingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>[]
        }
        delete: {
          args: Prisma.EntityAccountBindingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>
        }
        update: {
          args: Prisma.EntityAccountBindingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>
        }
        deleteMany: {
          args: Prisma.EntityAccountBindingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EntityAccountBindingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EntityAccountBindingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>[]
        }
        upsert: {
          args: Prisma.EntityAccountBindingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityAccountBindingPayload>
        }
        aggregate: {
          args: Prisma.EntityAccountBindingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEntityAccountBinding>
        }
        groupBy: {
          args: Prisma.EntityAccountBindingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EntityAccountBindingGroupByOutputType>[]
        }
        count: {
          args: Prisma.EntityAccountBindingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EntityAccountBindingCountAggregateOutputType> | number
        }
      }
    }
    EntityMetadata: {
      payload: Prisma.$EntityMetadataPayload<ExtArgs>
      fields: Prisma.EntityMetadataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EntityMetadataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EntityMetadataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>
        }
        findFirst: {
          args: Prisma.EntityMetadataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EntityMetadataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>
        }
        findMany: {
          args: Prisma.EntityMetadataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>[]
        }
        create: {
          args: Prisma.EntityMetadataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>
        }
        createMany: {
          args: Prisma.EntityMetadataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EntityMetadataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>[]
        }
        delete: {
          args: Prisma.EntityMetadataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>
        }
        update: {
          args: Prisma.EntityMetadataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>
        }
        deleteMany: {
          args: Prisma.EntityMetadataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EntityMetadataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EntityMetadataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>[]
        }
        upsert: {
          args: Prisma.EntityMetadataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EntityMetadataPayload>
        }
        aggregate: {
          args: Prisma.EntityMetadataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEntityMetadata>
        }
        groupBy: {
          args: Prisma.EntityMetadataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EntityMetadataGroupByOutputType>[]
        }
        count: {
          args: Prisma.EntityMetadataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EntityMetadataCountAggregateOutputType> | number
        }
      }
    }
    ConstructionProject: {
      payload: Prisma.$ConstructionProjectPayload<ExtArgs>
      fields: Prisma.ConstructionProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>
        }
        findFirst: {
          args: Prisma.ConstructionProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>
        }
        findMany: {
          args: Prisma.ConstructionProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>[]
        }
        create: {
          args: Prisma.ConstructionProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>
        }
        createMany: {
          args: Prisma.ConstructionProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>[]
        }
        delete: {
          args: Prisma.ConstructionProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>
        }
        update: {
          args: Prisma.ConstructionProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionProjectPayload>
        }
        aggregate: {
          args: Prisma.ConstructionProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionProject>
        }
        groupBy: {
          args: Prisma.ConstructionProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionProjectCountAggregateOutputType> | number
        }
      }
    }
    CostCode: {
      payload: Prisma.$CostCodePayload<ExtArgs>
      fields: Prisma.CostCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CostCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CostCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>
        }
        findFirst: {
          args: Prisma.CostCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CostCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>
        }
        findMany: {
          args: Prisma.CostCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>[]
        }
        create: {
          args: Prisma.CostCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>
        }
        createMany: {
          args: Prisma.CostCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CostCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>[]
        }
        delete: {
          args: Prisma.CostCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>
        }
        update: {
          args: Prisma.CostCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>
        }
        deleteMany: {
          args: Prisma.CostCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CostCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CostCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>[]
        }
        upsert: {
          args: Prisma.CostCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CostCodePayload>
        }
        aggregate: {
          args: Prisma.CostCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCostCode>
        }
        groupBy: {
          args: Prisma.CostCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.CostCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CostCodeCountAggregateOutputType> | number
        }
      }
    }
    ConstructionDailyLog: {
      payload: Prisma.$ConstructionDailyLogPayload<ExtArgs>
      fields: Prisma.ConstructionDailyLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionDailyLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionDailyLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>
        }
        findFirst: {
          args: Prisma.ConstructionDailyLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionDailyLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>
        }
        findMany: {
          args: Prisma.ConstructionDailyLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>[]
        }
        create: {
          args: Prisma.ConstructionDailyLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>
        }
        createMany: {
          args: Prisma.ConstructionDailyLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionDailyLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>[]
        }
        delete: {
          args: Prisma.ConstructionDailyLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>
        }
        update: {
          args: Prisma.ConstructionDailyLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionDailyLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionDailyLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionDailyLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionDailyLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionDailyLogPayload>
        }
        aggregate: {
          args: Prisma.ConstructionDailyLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionDailyLog>
        }
        groupBy: {
          args: Prisma.ConstructionDailyLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionDailyLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionDailyLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionDailyLogCountAggregateOutputType> | number
        }
      }
    }
    ConstructionCrew: {
      payload: Prisma.$ConstructionCrewPayload<ExtArgs>
      fields: Prisma.ConstructionCrewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionCrewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionCrewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>
        }
        findFirst: {
          args: Prisma.ConstructionCrewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionCrewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>
        }
        findMany: {
          args: Prisma.ConstructionCrewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>[]
        }
        create: {
          args: Prisma.ConstructionCrewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>
        }
        createMany: {
          args: Prisma.ConstructionCrewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionCrewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>[]
        }
        delete: {
          args: Prisma.ConstructionCrewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>
        }
        update: {
          args: Prisma.ConstructionCrewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionCrewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionCrewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionCrewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionCrewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionCrewPayload>
        }
        aggregate: {
          args: Prisma.ConstructionCrewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionCrew>
        }
        groupBy: {
          args: Prisma.ConstructionCrewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionCrewGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionCrewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionCrewCountAggregateOutputType> | number
        }
      }
    }
    ConstructionLabor: {
      payload: Prisma.$ConstructionLaborPayload<ExtArgs>
      fields: Prisma.ConstructionLaborFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionLaborFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionLaborFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>
        }
        findFirst: {
          args: Prisma.ConstructionLaborFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionLaborFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>
        }
        findMany: {
          args: Prisma.ConstructionLaborFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>[]
        }
        create: {
          args: Prisma.ConstructionLaborCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>
        }
        createMany: {
          args: Prisma.ConstructionLaborCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionLaborCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>[]
        }
        delete: {
          args: Prisma.ConstructionLaborDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>
        }
        update: {
          args: Prisma.ConstructionLaborUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionLaborDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionLaborUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionLaborUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionLaborUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionLaborPayload>
        }
        aggregate: {
          args: Prisma.ConstructionLaborAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionLabor>
        }
        groupBy: {
          args: Prisma.ConstructionLaborGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionLaborGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionLaborCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionLaborCountAggregateOutputType> | number
        }
      }
    }
    ConstructionEquipment: {
      payload: Prisma.$ConstructionEquipmentPayload<ExtArgs>
      fields: Prisma.ConstructionEquipmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionEquipmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionEquipmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>
        }
        findFirst: {
          args: Prisma.ConstructionEquipmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionEquipmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>
        }
        findMany: {
          args: Prisma.ConstructionEquipmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>[]
        }
        create: {
          args: Prisma.ConstructionEquipmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>
        }
        createMany: {
          args: Prisma.ConstructionEquipmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionEquipmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>[]
        }
        delete: {
          args: Prisma.ConstructionEquipmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>
        }
        update: {
          args: Prisma.ConstructionEquipmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionEquipmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionEquipmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionEquipmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionEquipmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentPayload>
        }
        aggregate: {
          args: Prisma.ConstructionEquipmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionEquipment>
        }
        groupBy: {
          args: Prisma.ConstructionEquipmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionEquipmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionEquipmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionEquipmentCountAggregateOutputType> | number
        }
      }
    }
    ConstructionEquipmentUsage: {
      payload: Prisma.$ConstructionEquipmentUsagePayload<ExtArgs>
      fields: Prisma.ConstructionEquipmentUsageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionEquipmentUsageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionEquipmentUsageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>
        }
        findFirst: {
          args: Prisma.ConstructionEquipmentUsageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionEquipmentUsageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>
        }
        findMany: {
          args: Prisma.ConstructionEquipmentUsageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>[]
        }
        create: {
          args: Prisma.ConstructionEquipmentUsageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>
        }
        createMany: {
          args: Prisma.ConstructionEquipmentUsageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionEquipmentUsageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>[]
        }
        delete: {
          args: Prisma.ConstructionEquipmentUsageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>
        }
        update: {
          args: Prisma.ConstructionEquipmentUsageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>
        }
        deleteMany: {
          args: Prisma.ConstructionEquipmentUsageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionEquipmentUsageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionEquipmentUsageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>[]
        }
        upsert: {
          args: Prisma.ConstructionEquipmentUsageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionEquipmentUsagePayload>
        }
        aggregate: {
          args: Prisma.ConstructionEquipmentUsageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionEquipmentUsage>
        }
        groupBy: {
          args: Prisma.ConstructionEquipmentUsageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionEquipmentUsageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionEquipmentUsageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionEquipmentUsageCountAggregateOutputType> | number
        }
      }
    }
    ConstructionInventoryItem: {
      payload: Prisma.$ConstructionInventoryItemPayload<ExtArgs>
      fields: Prisma.ConstructionInventoryItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionInventoryItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionInventoryItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>
        }
        findFirst: {
          args: Prisma.ConstructionInventoryItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionInventoryItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>
        }
        findMany: {
          args: Prisma.ConstructionInventoryItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>[]
        }
        create: {
          args: Prisma.ConstructionInventoryItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>
        }
        createMany: {
          args: Prisma.ConstructionInventoryItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionInventoryItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>[]
        }
        delete: {
          args: Prisma.ConstructionInventoryItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>
        }
        update: {
          args: Prisma.ConstructionInventoryItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionInventoryItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionInventoryItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionInventoryItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionInventoryItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionInventoryItemPayload>
        }
        aggregate: {
          args: Prisma.ConstructionInventoryItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionInventoryItem>
        }
        groupBy: {
          args: Prisma.ConstructionInventoryItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionInventoryItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionInventoryItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionInventoryItemCountAggregateOutputType> | number
        }
      }
    }
    ConstructionWarehouse: {
      payload: Prisma.$ConstructionWarehousePayload<ExtArgs>
      fields: Prisma.ConstructionWarehouseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionWarehouseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionWarehouseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>
        }
        findFirst: {
          args: Prisma.ConstructionWarehouseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionWarehouseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>
        }
        findMany: {
          args: Prisma.ConstructionWarehouseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>[]
        }
        create: {
          args: Prisma.ConstructionWarehouseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>
        }
        createMany: {
          args: Prisma.ConstructionWarehouseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionWarehouseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>[]
        }
        delete: {
          args: Prisma.ConstructionWarehouseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>
        }
        update: {
          args: Prisma.ConstructionWarehouseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>
        }
        deleteMany: {
          args: Prisma.ConstructionWarehouseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionWarehouseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionWarehouseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>[]
        }
        upsert: {
          args: Prisma.ConstructionWarehouseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionWarehousePayload>
        }
        aggregate: {
          args: Prisma.ConstructionWarehouseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionWarehouse>
        }
        groupBy: {
          args: Prisma.ConstructionWarehouseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionWarehouseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionWarehouseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionWarehouseCountAggregateOutputType> | number
        }
      }
    }
    ConstructionStockBalance: {
      payload: Prisma.$ConstructionStockBalancePayload<ExtArgs>
      fields: Prisma.ConstructionStockBalanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionStockBalanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionStockBalanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>
        }
        findFirst: {
          args: Prisma.ConstructionStockBalanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionStockBalanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>
        }
        findMany: {
          args: Prisma.ConstructionStockBalanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>[]
        }
        create: {
          args: Prisma.ConstructionStockBalanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>
        }
        createMany: {
          args: Prisma.ConstructionStockBalanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionStockBalanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>[]
        }
        delete: {
          args: Prisma.ConstructionStockBalanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>
        }
        update: {
          args: Prisma.ConstructionStockBalanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>
        }
        deleteMany: {
          args: Prisma.ConstructionStockBalanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionStockBalanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionStockBalanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>[]
        }
        upsert: {
          args: Prisma.ConstructionStockBalanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionStockBalancePayload>
        }
        aggregate: {
          args: Prisma.ConstructionStockBalanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionStockBalance>
        }
        groupBy: {
          args: Prisma.ConstructionStockBalanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionStockBalanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionStockBalanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionStockBalanceCountAggregateOutputType> | number
        }
      }
    }
    ConstructionGRN: {
      payload: Prisma.$ConstructionGRNPayload<ExtArgs>
      fields: Prisma.ConstructionGRNFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionGRNFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionGRNFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>
        }
        findFirst: {
          args: Prisma.ConstructionGRNFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionGRNFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>
        }
        findMany: {
          args: Prisma.ConstructionGRNFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>[]
        }
        create: {
          args: Prisma.ConstructionGRNCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>
        }
        createMany: {
          args: Prisma.ConstructionGRNCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionGRNCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>[]
        }
        delete: {
          args: Prisma.ConstructionGRNDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>
        }
        update: {
          args: Prisma.ConstructionGRNUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionGRNDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionGRNUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionGRNUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionGRNUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNPayload>
        }
        aggregate: {
          args: Prisma.ConstructionGRNAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionGRN>
        }
        groupBy: {
          args: Prisma.ConstructionGRNGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionGRNGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionGRNCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionGRNCountAggregateOutputType> | number
        }
      }
    }
    ConstructionGRNItem: {
      payload: Prisma.$ConstructionGRNItemPayload<ExtArgs>
      fields: Prisma.ConstructionGRNItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionGRNItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionGRNItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>
        }
        findFirst: {
          args: Prisma.ConstructionGRNItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionGRNItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>
        }
        findMany: {
          args: Prisma.ConstructionGRNItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>[]
        }
        create: {
          args: Prisma.ConstructionGRNItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>
        }
        createMany: {
          args: Prisma.ConstructionGRNItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionGRNItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>[]
        }
        delete: {
          args: Prisma.ConstructionGRNItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>
        }
        update: {
          args: Prisma.ConstructionGRNItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionGRNItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionGRNItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionGRNItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionGRNItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionGRNItemPayload>
        }
        aggregate: {
          args: Prisma.ConstructionGRNItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionGRNItem>
        }
        groupBy: {
          args: Prisma.ConstructionGRNItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionGRNItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionGRNItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionGRNItemCountAggregateOutputType> | number
        }
      }
    }
    ConstructionIssue: {
      payload: Prisma.$ConstructionIssuePayload<ExtArgs>
      fields: Prisma.ConstructionIssueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionIssueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionIssueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>
        }
        findFirst: {
          args: Prisma.ConstructionIssueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionIssueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>
        }
        findMany: {
          args: Prisma.ConstructionIssueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>[]
        }
        create: {
          args: Prisma.ConstructionIssueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>
        }
        createMany: {
          args: Prisma.ConstructionIssueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionIssueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>[]
        }
        delete: {
          args: Prisma.ConstructionIssueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>
        }
        update: {
          args: Prisma.ConstructionIssueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>
        }
        deleteMany: {
          args: Prisma.ConstructionIssueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionIssueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionIssueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>[]
        }
        upsert: {
          args: Prisma.ConstructionIssueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssuePayload>
        }
        aggregate: {
          args: Prisma.ConstructionIssueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionIssue>
        }
        groupBy: {
          args: Prisma.ConstructionIssueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionIssueGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionIssueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionIssueCountAggregateOutputType> | number
        }
      }
    }
    ConstructionIssueItem: {
      payload: Prisma.$ConstructionIssueItemPayload<ExtArgs>
      fields: Prisma.ConstructionIssueItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionIssueItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionIssueItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>
        }
        findFirst: {
          args: Prisma.ConstructionIssueItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionIssueItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>
        }
        findMany: {
          args: Prisma.ConstructionIssueItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>[]
        }
        create: {
          args: Prisma.ConstructionIssueItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>
        }
        createMany: {
          args: Prisma.ConstructionIssueItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionIssueItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>[]
        }
        delete: {
          args: Prisma.ConstructionIssueItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>
        }
        update: {
          args: Prisma.ConstructionIssueItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionIssueItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionIssueItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionIssueItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionIssueItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionIssueItemPayload>
        }
        aggregate: {
          args: Prisma.ConstructionIssueItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionIssueItem>
        }
        groupBy: {
          args: Prisma.ConstructionIssueItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionIssueItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionIssueItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionIssueItemCountAggregateOutputType> | number
        }
      }
    }
    ConstructionConsumption: {
      payload: Prisma.$ConstructionConsumptionPayload<ExtArgs>
      fields: Prisma.ConstructionConsumptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionConsumptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionConsumptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>
        }
        findFirst: {
          args: Prisma.ConstructionConsumptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionConsumptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>
        }
        findMany: {
          args: Prisma.ConstructionConsumptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>[]
        }
        create: {
          args: Prisma.ConstructionConsumptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>
        }
        createMany: {
          args: Prisma.ConstructionConsumptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionConsumptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>[]
        }
        delete: {
          args: Prisma.ConstructionConsumptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>
        }
        update: {
          args: Prisma.ConstructionConsumptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionConsumptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionConsumptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionConsumptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionConsumptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionConsumptionPayload>
        }
        aggregate: {
          args: Prisma.ConstructionConsumptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionConsumption>
        }
        groupBy: {
          args: Prisma.ConstructionConsumptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionConsumptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionConsumptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionConsumptionCountAggregateOutputType> | number
        }
      }
    }
    ConstructionBudget: {
      payload: Prisma.$ConstructionBudgetPayload<ExtArgs>
      fields: Prisma.ConstructionBudgetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionBudgetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionBudgetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>
        }
        findFirst: {
          args: Prisma.ConstructionBudgetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionBudgetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>
        }
        findMany: {
          args: Prisma.ConstructionBudgetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>[]
        }
        create: {
          args: Prisma.ConstructionBudgetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>
        }
        createMany: {
          args: Prisma.ConstructionBudgetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionBudgetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>[]
        }
        delete: {
          args: Prisma.ConstructionBudgetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>
        }
        update: {
          args: Prisma.ConstructionBudgetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>
        }
        deleteMany: {
          args: Prisma.ConstructionBudgetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionBudgetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionBudgetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>[]
        }
        upsert: {
          args: Prisma.ConstructionBudgetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionBudgetPayload>
        }
        aggregate: {
          args: Prisma.ConstructionBudgetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionBudget>
        }
        groupBy: {
          args: Prisma.ConstructionBudgetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionBudgetGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionBudgetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionBudgetCountAggregateOutputType> | number
        }
      }
    }
    ConstructionMilestone: {
      payload: Prisma.$ConstructionMilestonePayload<ExtArgs>
      fields: Prisma.ConstructionMilestoneFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionMilestoneFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionMilestoneFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>
        }
        findFirst: {
          args: Prisma.ConstructionMilestoneFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionMilestoneFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>
        }
        findMany: {
          args: Prisma.ConstructionMilestoneFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>[]
        }
        create: {
          args: Prisma.ConstructionMilestoneCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>
        }
        createMany: {
          args: Prisma.ConstructionMilestoneCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionMilestoneCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>[]
        }
        delete: {
          args: Prisma.ConstructionMilestoneDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>
        }
        update: {
          args: Prisma.ConstructionMilestoneUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>
        }
        deleteMany: {
          args: Prisma.ConstructionMilestoneDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionMilestoneUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionMilestoneUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>[]
        }
        upsert: {
          args: Prisma.ConstructionMilestoneUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionMilestonePayload>
        }
        aggregate: {
          args: Prisma.ConstructionMilestoneAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionMilestone>
        }
        groupBy: {
          args: Prisma.ConstructionMilestoneGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionMilestoneGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionMilestoneCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionMilestoneCountAggregateOutputType> | number
        }
      }
    }
    ConstructionPostingRule: {
      payload: Prisma.$ConstructionPostingRulePayload<ExtArgs>
      fields: Prisma.ConstructionPostingRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConstructionPostingRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConstructionPostingRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>
        }
        findFirst: {
          args: Prisma.ConstructionPostingRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConstructionPostingRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>
        }
        findMany: {
          args: Prisma.ConstructionPostingRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>[]
        }
        create: {
          args: Prisma.ConstructionPostingRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>
        }
        createMany: {
          args: Prisma.ConstructionPostingRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConstructionPostingRuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>[]
        }
        delete: {
          args: Prisma.ConstructionPostingRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>
        }
        update: {
          args: Prisma.ConstructionPostingRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>
        }
        deleteMany: {
          args: Prisma.ConstructionPostingRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConstructionPostingRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConstructionPostingRuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>[]
        }
        upsert: {
          args: Prisma.ConstructionPostingRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConstructionPostingRulePayload>
        }
        aggregate: {
          args: Prisma.ConstructionPostingRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConstructionPostingRule>
        }
        groupBy: {
          args: Prisma.ConstructionPostingRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionPostingRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConstructionPostingRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConstructionPostingRuleCountAggregateOutputType> | number
        }
      }
    }
    ExportJob: {
      payload: Prisma.$ExportJobPayload<ExtArgs>
      fields: Prisma.ExportJobFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExportJobFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExportJobFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>
        }
        findFirst: {
          args: Prisma.ExportJobFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExportJobFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>
        }
        findMany: {
          args: Prisma.ExportJobFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>[]
        }
        create: {
          args: Prisma.ExportJobCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>
        }
        createMany: {
          args: Prisma.ExportJobCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExportJobCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>[]
        }
        delete: {
          args: Prisma.ExportJobDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>
        }
        update: {
          args: Prisma.ExportJobUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>
        }
        deleteMany: {
          args: Prisma.ExportJobDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExportJobUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExportJobUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>[]
        }
        upsert: {
          args: Prisma.ExportJobUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExportJobPayload>
        }
        aggregate: {
          args: Prisma.ExportJobAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExportJob>
        }
        groupBy: {
          args: Prisma.ExportJobGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExportJobGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExportJobCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExportJobCountAggregateOutputType> | number
        }
      }
    }
    FilterPreset: {
      payload: Prisma.$FilterPresetPayload<ExtArgs>
      fields: Prisma.FilterPresetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FilterPresetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FilterPresetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>
        }
        findFirst: {
          args: Prisma.FilterPresetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FilterPresetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>
        }
        findMany: {
          args: Prisma.FilterPresetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>[]
        }
        create: {
          args: Prisma.FilterPresetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>
        }
        createMany: {
          args: Prisma.FilterPresetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FilterPresetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>[]
        }
        delete: {
          args: Prisma.FilterPresetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>
        }
        update: {
          args: Prisma.FilterPresetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>
        }
        deleteMany: {
          args: Prisma.FilterPresetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FilterPresetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FilterPresetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>[]
        }
        upsert: {
          args: Prisma.FilterPresetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FilterPresetPayload>
        }
        aggregate: {
          args: Prisma.FilterPresetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFilterPreset>
        }
        groupBy: {
          args: Prisma.FilterPresetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterPresetGroupByOutputType>[]
        }
        count: {
          args: Prisma.FilterPresetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FilterPresetCountAggregateOutputType> | number
        }
      }
    }
    FinancialOperation: {
      payload: Prisma.$FinancialOperationPayload<ExtArgs>
      fields: Prisma.FinancialOperationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinancialOperationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinancialOperationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>
        }
        findFirst: {
          args: Prisma.FinancialOperationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinancialOperationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>
        }
        findMany: {
          args: Prisma.FinancialOperationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>[]
        }
        create: {
          args: Prisma.FinancialOperationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>
        }
        createMany: {
          args: Prisma.FinancialOperationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinancialOperationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>[]
        }
        delete: {
          args: Prisma.FinancialOperationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>
        }
        update: {
          args: Prisma.FinancialOperationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>
        }
        deleteMany: {
          args: Prisma.FinancialOperationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinancialOperationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinancialOperationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>[]
        }
        upsert: {
          args: Prisma.FinancialOperationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationPayload>
        }
        aggregate: {
          args: Prisma.FinancialOperationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialOperation>
        }
        groupBy: {
          args: Prisma.FinancialOperationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialOperationGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinancialOperationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialOperationCountAggregateOutputType> | number
        }
      }
    }
    FinancialOperationLine: {
      payload: Prisma.$FinancialOperationLinePayload<ExtArgs>
      fields: Prisma.FinancialOperationLineFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinancialOperationLineFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinancialOperationLineFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>
        }
        findFirst: {
          args: Prisma.FinancialOperationLineFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinancialOperationLineFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>
        }
        findMany: {
          args: Prisma.FinancialOperationLineFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>[]
        }
        create: {
          args: Prisma.FinancialOperationLineCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>
        }
        createMany: {
          args: Prisma.FinancialOperationLineCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinancialOperationLineCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>[]
        }
        delete: {
          args: Prisma.FinancialOperationLineDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>
        }
        update: {
          args: Prisma.FinancialOperationLineUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>
        }
        deleteMany: {
          args: Prisma.FinancialOperationLineDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinancialOperationLineUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinancialOperationLineUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>[]
        }
        upsert: {
          args: Prisma.FinancialOperationLineUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationLinePayload>
        }
        aggregate: {
          args: Prisma.FinancialOperationLineAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialOperationLine>
        }
        groupBy: {
          args: Prisma.FinancialOperationLineGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialOperationLineGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinancialOperationLineCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialOperationLineCountAggregateOutputType> | number
        }
      }
    }
    FinancialOperationReference: {
      payload: Prisma.$FinancialOperationReferencePayload<ExtArgs>
      fields: Prisma.FinancialOperationReferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FinancialOperationReferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FinancialOperationReferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>
        }
        findFirst: {
          args: Prisma.FinancialOperationReferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FinancialOperationReferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>
        }
        findMany: {
          args: Prisma.FinancialOperationReferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>[]
        }
        create: {
          args: Prisma.FinancialOperationReferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>
        }
        createMany: {
          args: Prisma.FinancialOperationReferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FinancialOperationReferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>[]
        }
        delete: {
          args: Prisma.FinancialOperationReferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>
        }
        update: {
          args: Prisma.FinancialOperationReferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>
        }
        deleteMany: {
          args: Prisma.FinancialOperationReferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FinancialOperationReferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FinancialOperationReferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>[]
        }
        upsert: {
          args: Prisma.FinancialOperationReferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FinancialOperationReferencePayload>
        }
        aggregate: {
          args: Prisma.FinancialOperationReferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFinancialOperationReference>
        }
        groupBy: {
          args: Prisma.FinancialOperationReferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialOperationReferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.FinancialOperationReferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FinancialOperationReferenceCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  username: 'username',
  email: 'email',
  password: 'password',
  roleId: 'roleId',
  deviceApprovalStatus: 'deviceApprovalStatus',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  status: 'status',
  category: 'category',
  permissions: 'permissions',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  defaultPassword: 'defaultPassword'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const RolePermissionScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  module: 'module',
  submodule: 'submodule',
  action: 'action',
  granted: 'granted',
  createdAt: 'createdAt',
  createdBy: 'createdBy'
} as const

export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


export const PermissionAuditLogScalarFieldEnum = {
  id: 'id',
  actorId: 'actorId',
  actorUsername: 'actorUsername',
  roleId: 'roleId',
  roleName: 'roleName',
  permissionPath: 'permissionPath',
  oldValue: 'oldValue',
  newValue: 'newValue',
  changeType: 'changeType',
  context: 'context',
  createdAt: 'createdAt'
} as const

export type PermissionAuditLogScalarFieldEnum = (typeof PermissionAuditLogScalarFieldEnum)[keyof typeof PermissionAuditLogScalarFieldEnum]


export const ActionAuditLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  username: 'username',
  roleId: 'roleId',
  roleName: 'roleName',
  permissionUsed: 'permissionUsed',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  requestPath: 'requestPath',
  requestMethod: 'requestMethod',
  requestContext: 'requestContext',
  result: 'result',
  createdAt: 'createdAt'
} as const

export type ActionAuditLogScalarFieldEnum = (typeof ActionAuditLogScalarFieldEnum)[keyof typeof ActionAuditLogScalarFieldEnum]


export const RoleLifecycleAuditLogScalarFieldEnum = {
  id: 'id',
  actorId: 'actorId',
  actorUsername: 'actorUsername',
  roleId: 'roleId',
  roleName: 'roleName',
  previousStatus: 'previousStatus',
  newStatus: 'newStatus',
  affectedUsers: 'affectedUsers',
  reassignmentMap: 'reassignmentMap',
  reason: 'reason',
  context: 'context',
  createdAt: 'createdAt'
} as const

export type RoleLifecycleAuditLogScalarFieldEnum = (typeof RoleLifecycleAuditLogScalarFieldEnum)[keyof typeof RoleLifecycleAuditLogScalarFieldEnum]


export const RoleInviteLinkScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  username: 'username',
  email: 'email',
  password: 'password',
  message: 'message',
  token: 'token',
  status: 'status',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt'
} as const

export type RoleInviteLinkScalarFieldEnum = (typeof RoleInviteLinkScalarFieldEnum)[keyof typeof RoleInviteLinkScalarFieldEnum]


export const DeviceApprovalScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  deviceInfo: 'deviceInfo',
  status: 'status',
  requestedAt: 'requestedAt',
  approvedAt: 'approvedAt'
} as const

export type DeviceApprovalScalarFieldEnum = (typeof DeviceApprovalScalarFieldEnum)[keyof typeof DeviceApprovalScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  title: 'title',
  message: 'message',
  type: 'type',
  read: 'read',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const PropertyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  address: 'address',
  location: 'location',
  status: 'status',
  imageUrl: 'imageUrl',
  description: 'description',
  yearBuilt: 'yearBuilt',
  totalArea: 'totalArea',
  totalUnits: 'totalUnits',
  dealerId: 'dealerId',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  propertyCode: 'propertyCode',
  city: 'city',
  documents: 'documents',
  ownerName: 'ownerName',
  ownerPhone: 'ownerPhone',
  previousTenants: 'previousTenants',
  rentAmount: 'rentAmount',
  rentEscalationPercentage: 'rentEscalationPercentage',
  securityDeposit: 'securityDeposit',
  size: 'size',
  title: 'title',
  locationId: 'locationId',
  manualUniqueId: 'manualUniqueId',
  propertySubsidiary: 'propertySubsidiary',
  amenities: 'amenities',
  salePrice: 'salePrice',
  subsidiaryOptionId: 'subsidiaryOptionId',
  tid: 'tid',
  category: 'category'
} as const

export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


export const LocationScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  parentId: 'parentId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isActive: 'isActive',
  isLeaf: 'isLeaf'
} as const

export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


export const PropertySubsidiaryScalarFieldEnum = {
  id: 'id',
  locationId: 'locationId',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isActive: 'isActive',
  logoPath: 'logoPath'
} as const

export type PropertySubsidiaryScalarFieldEnum = (typeof PropertySubsidiaryScalarFieldEnum)[keyof typeof PropertySubsidiaryScalarFieldEnum]


export const SubsidiaryOptionScalarFieldEnum = {
  id: 'id',
  propertySubsidiaryId: 'propertySubsidiaryId',
  name: 'name',
  sortOrder: 'sortOrder',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SubsidiaryOptionScalarFieldEnum = (typeof SubsidiaryOptionScalarFieldEnum)[keyof typeof SubsidiaryOptionScalarFieldEnum]


export const BlockScalarFieldEnum = {
  id: 'id',
  name: 'name',
  propertyId: 'propertyId',
  description: 'description',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


export const FloorScalarFieldEnum = {
  id: 'id',
  name: 'name',
  floorNumber: 'floorNumber',
  propertyId: 'propertyId',
  description: 'description',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FloorScalarFieldEnum = (typeof FloorScalarFieldEnum)[keyof typeof FloorScalarFieldEnum]


export const UnitScalarFieldEnum = {
  id: 'id',
  unitName: 'unitName',
  propertyId: 'propertyId',
  blockId: 'blockId',
  status: 'status',
  monthlyRent: 'monthlyRent',
  description: 'description',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  floorId: 'floorId',
  maintenanceHistory: 'maintenanceHistory',
  unitType: 'unitType',
  sizeSqFt: 'sizeSqFt',
  securityDeposit: 'securityDeposit',
  utilitiesIncluded: 'utilitiesIncluded',
  tid: 'tid'
} as const

export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


export const TenantScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  unitId: 'unitId',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  cnic: 'cnic',
  tenantCode: 'tenantCode',
  advanceBalance: 'advanceBalance',
  cnicDocumentUrl: 'cnicDocumentUrl',
  isActive: 'isActive',
  lastLoginAt: 'lastLoginAt',
  outstandingBalance: 'outstandingBalance',
  password: 'password',
  profilePhotoUrl: 'profilePhotoUrl',
  tid: 'tid'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const LeaseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  unitId: 'unitId',
  leaseStart: 'leaseStart',
  leaseEnd: 'leaseEnd',
  rent: 'rent',
  status: 'status',
  notes: 'notes',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  leaseDocumentUrl: 'leaseDocumentUrl',
  leaseNumber: 'leaseNumber',
  noticePeriod: 'noticePeriod',
  renewalDate: 'renewalDate',
  renewalHistory: 'renewalHistory',
  rentTerms: 'rentTerms',
  securityDeposit: 'securityDeposit',
  termsAndConditions: 'termsAndConditions',
  updatedBy: 'updatedBy',
  tid: 'tid'
} as const

export type LeaseScalarFieldEnum = (typeof LeaseScalarFieldEnum)[keyof typeof LeaseScalarFieldEnum]


export const SaleScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  saleValue: 'saleValue',
  commission: 'commission',
  commissionRate: 'commissionRate',
  saleDate: 'saleDate',
  status: 'status',
  notes: 'notes',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  actualPropertyValue: 'actualPropertyValue',
  buyerId: 'buyerId',
  dealerId: 'dealerId',
  documents: 'documents',
  profit: 'profit',
  tid: 'tid'
} as const

export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


export const SaleInstallmentScalarFieldEnum = {
  id: 'id',
  saleId: 'saleId',
  installmentNumber: 'installmentNumber',
  amount: 'amount',
  dueDate: 'dueDate',
  paidDate: 'paidDate',
  status: 'status',
  paidAmount: 'paidAmount',
  notes: 'notes',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SaleInstallmentScalarFieldEnum = (typeof SaleInstallmentScalarFieldEnum)[keyof typeof SaleInstallmentScalarFieldEnum]


export const BuyerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  address: 'address',
  propertyId: 'propertyId',
  saleId: 'saleId',
  buyStatus: 'buyStatus',
  buyValue: 'buyValue',
  notes: 'notes',
  tid: 'tid',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BuyerScalarFieldEnum = (typeof BuyerScalarFieldEnum)[keyof typeof BuyerScalarFieldEnum]


export const ActivityScalarFieldEnum = {
  id: 'id',
  type: 'type',
  action: 'action',
  entityId: 'entityId',
  entityName: 'entityName',
  message: 'message',
  userId: 'userId',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  content: 'content',
  senderId: 'senderId',
  senderName: 'senderName',
  senderRole: 'senderRole',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  senderEmail: 'senderEmail'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const DepartmentScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


export const EmployeeScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  name: 'name',
  email: 'email',
  phone: 'phone',
  position: 'position',
  department: 'department',
  salary: 'salary',
  joinDate: 'joinDate',
  status: 'status',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  cnic: 'cnic',
  address: 'address',
  attendanceQRCode: 'attendanceQRCode',
  bankAccountNumber: 'bankAccountNumber',
  bankBranch: 'bankBranch',
  bankName: 'bankName',
  basicSalary: 'basicSalary',
  benefitsEligible: 'benefitsEligible',
  bloodGroup: 'bloodGroup',
  city: 'city',
  cnicDocumentUrl: 'cnicDocumentUrl',
  country: 'country',
  dateOfBirth: 'dateOfBirth',
  departmentCode: 'departmentCode',
  education: 'education',
  emergencyContactName: 'emergencyContactName',
  emergencyContactPhone: 'emergencyContactPhone',
  emergencyContactRelation: 'emergencyContactRelation',
  employeeType: 'employeeType',
  experience: 'experience',
  gender: 'gender',
  iban: 'iban',
  insuranceEligible: 'insuranceEligible',
  maritalStatus: 'maritalStatus',
  nationality: 'nationality',
  postalCode: 'postalCode',
  probationEndDate: 'probationEndDate',
  probationPeriod: 'probationPeriod',
  profilePhotoUrl: 'profilePhotoUrl',
  reportingManagerId: 'reportingManagerId',
  role: 'role',
  shiftTimings: 'shiftTimings',
  workLocation: 'workLocation',
  tid: 'tid',
  trackingId: 'trackingId'
} as const

export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


export const AttendanceScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  date: 'date',
  checkIn: 'checkIn',
  checkOut: 'checkOut',
  status: 'status',
  hours: 'hours',
  totalWorkDuration: 'totalWorkDuration',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  checkInLocation: 'checkInLocation',
  checkOutLocation: 'checkOutLocation',
  deviceId: 'deviceId',
  graceMinutes: 'graceMinutes',
  isManualOverride: 'isManualOverride',
  isNightShift: 'isNightShift',
  isSuspicious: 'isSuspicious',
  lateMinutes: 'lateMinutes',
  overrideBy: 'overrideBy',
  overrideReason: 'overrideReason',
  overtimeHours: 'overtimeHours',
  shiftId: 'shiftId',
  suspiciousReason: 'suspiciousReason'
} as const

export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


export const AttendanceCorrectionScalarFieldEnum = {
  id: 'id',
  attendanceId: 'attendanceId',
  employeeId: 'employeeId',
  requestedDate: 'requestedDate',
  originalCheckIn: 'originalCheckIn',
  originalCheckOut: 'originalCheckOut',
  requestedCheckIn: 'requestedCheckIn',
  requestedCheckOut: 'requestedCheckOut',
  reason: 'reason',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectionReason: 'rejectionReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AttendanceCorrectionScalarFieldEnum = (typeof AttendanceCorrectionScalarFieldEnum)[keyof typeof AttendanceCorrectionScalarFieldEnum]


export const PayrollScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  month: 'month',
  baseSalary: 'baseSalary',
  bonus: 'bonus',
  deductions: 'deductions',
  netPay: 'netPay',
  paidAmount: 'paidAmount',
  remainingBalance: 'remainingBalance',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  advanceDeduction: 'advanceDeduction',
  allowances: 'allowances',
  basicSalary: 'basicSalary',
  epfAmount: 'epfAmount',
  etfAmount: 'etfAmount',
  financeLinked: 'financeLinked',
  grossSalary: 'grossSalary',
  insuranceAmount: 'insuranceAmount',
  journalEntryId: 'journalEntryId',
  notes: 'notes',
  overtimeAmount: 'overtimeAmount',
  paymentDate: 'paymentDate',
  paymentMethod: 'paymentMethod',
  paymentStatus: 'paymentStatus',
  payslipUrl: 'payslipUrl',
  taxAmount: 'taxAmount',
  taxPercent: 'taxPercent',
  financeLedgerId: 'financeLedgerId'
} as const

export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


export const PayrollAllowanceScalarFieldEnum = {
  id: 'id',
  payrollId: 'payrollId',
  employeeId: 'employeeId',
  type: 'type',
  amount: 'amount',
  description: 'description',
  createdAt: 'createdAt'
} as const

export type PayrollAllowanceScalarFieldEnum = (typeof PayrollAllowanceScalarFieldEnum)[keyof typeof PayrollAllowanceScalarFieldEnum]


export const PayrollDeductionScalarFieldEnum = {
  id: 'id',
  payrollId: 'payrollId',
  employeeId: 'employeeId',
  type: 'type',
  amount: 'amount',
  description: 'description',
  createdAt: 'createdAt'
} as const

export type PayrollDeductionScalarFieldEnum = (typeof PayrollDeductionScalarFieldEnum)[keyof typeof PayrollDeductionScalarFieldEnum]


export const PayrollPaymentScalarFieldEnum = {
  id: 'id',
  payrollId: 'payrollId',
  amount: 'amount',
  paymentDate: 'paymentDate',
  paymentMethod: 'paymentMethod',
  referenceNumber: 'referenceNumber',
  transactionId: 'transactionId',
  notes: 'notes',
  createdByUserId: 'createdByUserId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayrollPaymentScalarFieldEnum = (typeof PayrollPaymentScalarFieldEnum)[keyof typeof PayrollPaymentScalarFieldEnum]


export const SalaryHistoryScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  previousSalary: 'previousSalary',
  newSalary: 'newSalary',
  effectiveDate: 'effectiveDate',
  reason: 'reason',
  approvedBy: 'approvedBy',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type SalaryHistoryScalarFieldEnum = (typeof SalaryHistoryScalarFieldEnum)[keyof typeof SalaryHistoryScalarFieldEnum]


export const LeaveRequestScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  type: 'type',
  startDate: 'startDate',
  endDate: 'endDate',
  days: 'days',
  reason: 'reason',
  status: 'status',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  approvalLevel: 'approvalLevel',
  approvalReason: 'approvalReason',
  approvedAt: 'approvedAt',
  approvedBy: 'approvedBy',
  halfDayType: 'halfDayType',
  isHalfDay: 'isHalfDay',
  leaveBalance: 'leaveBalance',
  payrollDeduction: 'payrollDeduction',
  proofDocumentUrl: 'proofDocumentUrl',
  rejectedAt: 'rejectedAt',
  rejectedBy: 'rejectedBy',
  rejectionReason: 'rejectionReason'
} as const

export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


export const LeaveBalanceScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  leaveType: 'leaveType',
  totalAllocated: 'totalAllocated',
  used: 'used',
  pending: 'pending',
  available: 'available',
  carryForward: 'carryForward',
  year: 'year',
  accrualRate: 'accrualRate',
  maxCarryForward: 'maxCarryForward',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaveBalanceScalarFieldEnum = (typeof LeaveBalanceScalarFieldEnum)[keyof typeof LeaveBalanceScalarFieldEnum]


export const PublicHolidayScalarFieldEnum = {
  id: 'id',
  name: 'name',
  date: 'date',
  description: 'description',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PublicHolidayScalarFieldEnum = (typeof PublicHolidayScalarFieldEnum)[keyof typeof PublicHolidayScalarFieldEnum]


export const LeadScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  source: 'source',
  interest: 'interest',
  budget: 'budget',
  notes: 'notes',
  status: 'status',
  assignedTo: 'assignedTo',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  address: 'address',
  cnic: 'cnic',
  leadCode: 'leadCode',
  assignedToUserId: 'assignedToUserId',
  attachments: 'attachments',
  budgetMax: 'budgetMax',
  budgetMin: 'budgetMin',
  city: 'city',
  communicationPreference: 'communicationPreference',
  convertedAt: 'convertedAt',
  convertedToClientId: 'convertedToClientId',
  country: 'country',
  createdBy: 'createdBy',
  expectedCloseDate: 'expectedCloseDate',
  followUpDate: 'followUpDate',
  interestType: 'interestType',
  isDeleted: 'isDeleted',
  latitude: 'latitude',
  leadSourceDetails: 'leadSourceDetails',
  longitude: 'longitude',
  postalCode: 'postalCode',
  priority: 'priority',
  score: 'score',
  tags: 'tags',
  temperature: 'temperature',
  updatedBy: 'updatedBy',
  manualUniqueId: 'manualUniqueId',
  assignedDealerId: 'assignedDealerId',
  tid: 'tid'
} as const

export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


export const LeadImportBatchScalarFieldEnum = {
  id: 'id',
  fileName: 'fileName',
  fileHash: 'fileHash',
  filePath: 'filePath',
  rowCount: 'rowCount',
  readyCount: 'readyCount',
  duplicateCount: 'duplicateCount',
  invalidCount: 'invalidCount',
  status: 'status',
  createdByUserId: 'createdByUserId',
  createdAt: 'createdAt',
  committedAt: 'committedAt',
  errorSummary: 'errorSummary'
} as const

export type LeadImportBatchScalarFieldEnum = (typeof LeadImportBatchScalarFieldEnum)[keyof typeof LeadImportBatchScalarFieldEnum]


export const LeadImportRowScalarFieldEnum = {
  id: 'id',
  batchId: 'batchId',
  rowNumber: 'rowNumber',
  fullName: 'fullName',
  phone: 'phone',
  email: 'email',
  cnic: 'cnic',
  leadSource: 'leadSource',
  sourceDetails: 'sourceDetails',
  dealerTid: 'dealerTid',
  dealerEmail: 'dealerEmail',
  notes: 'notes',
  status: 'status',
  errors: 'errors',
  duplicateOfLeadId: 'duplicateOfLeadId',
  duplicateOfClientId: 'duplicateOfClientId',
  resolvedDealerId: 'resolvedDealerId',
  assignmentMode: 'assignmentMode',
  createdLeadId: 'createdLeadId',
  createdAt: 'createdAt'
} as const

export type LeadImportRowScalarFieldEnum = (typeof LeadImportRowScalarFieldEnum)[keyof typeof LeadImportRowScalarFieldEnum]


export const ClientScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  company: 'company',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  address: 'address',
  clientCode: 'clientCode',
  clientNo: 'clientNo',
  cnic: 'cnic',
  srNo: 'srNo',
  assignedAgentId: 'assignedAgentId',
  assignedDealerId: 'assignedDealerId',
  attachments: 'attachments',
  billingAddress: 'billingAddress',
  city: 'city',
  clientCategory: 'clientCategory',
  clientType: 'clientType',
  cnicDocumentUrl: 'cnicDocumentUrl',
  convertedFromLeadId: 'convertedFromLeadId',
  country: 'country',
  createdBy: 'createdBy',
  isDeleted: 'isDeleted',
  postalCode: 'postalCode',
  propertyInterest: 'propertyInterest',
  tags: 'tags',
  updatedBy: 'updatedBy',
  manualUniqueId: 'manualUniqueId',
  propertySubsidiary: 'propertySubsidiary',
  tid: 'tid'
} as const

export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


export const ContactPersonScalarFieldEnum = {
  id: 'id',
  clientId: 'clientId',
  name: 'name',
  email: 'email',
  phone: 'phone',
  position: 'position',
  department: 'department',
  isPrimary: 'isPrimary',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ContactPersonScalarFieldEnum = (typeof ContactPersonScalarFieldEnum)[keyof typeof ContactPersonScalarFieldEnum]


export const DealerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  company: 'company',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  commissionRate: 'commissionRate',
  address: 'address',
  cnic: 'cnic',
  dealerCode: 'dealerCode',
  agreementContractUrl: 'agreementContractUrl',
  assignedRegion: 'assignedRegion',
  bankAccountNumber: 'bankAccountNumber',
  bankBranch: 'bankBranch',
  bankName: 'bankName',
  city: 'city',
  cnicImageUrl: 'cnicImageUrl',
  country: 'country',
  createdBy: 'createdBy',
  currentPipelineValue: 'currentPipelineValue',
  experienceYears: 'experienceYears',
  iban: 'iban',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  notes: 'notes',
  postalCode: 'postalCode',
  qualifications: 'qualifications',
  rating: 'rating',
  settlementHistory: 'settlementHistory',
  tags: 'tags',
  totalCommissionEarned: 'totalCommissionEarned',
  totalDealsClosed: 'totalDealsClosed',
  updatedBy: 'updatedBy',
  manualUniqueId: 'manualUniqueId',
  tid: 'tid'
} as const

export type DealerScalarFieldEnum = (typeof DealerScalarFieldEnum)[keyof typeof DealerScalarFieldEnum]


export const DealerReviewScalarFieldEnum = {
  id: 'id',
  dealerId: 'dealerId',
  rating: 'rating',
  comment: 'comment',
  reviewedBy: 'reviewedBy',
  createdAt: 'createdAt'
} as const

export type DealerReviewScalarFieldEnum = (typeof DealerReviewScalarFieldEnum)[keyof typeof DealerReviewScalarFieldEnum]


export const DealScalarFieldEnum = {
  id: 'id',
  title: 'title',
  dealAmount: 'dealAmount',
  listingPriceSnapshot: 'listingPriceSnapshot',
  varianceAmount: 'varianceAmount',
  varianceType: 'varianceType',
  stage: 'stage',
  clientId: 'clientId',
  dealerId: 'dealerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  actualClosingDate: 'actualClosingDate',
  approvedAt: 'approvedAt',
  approvedBy: 'approvedBy',
  attachments: 'attachments',
  commissionAmount: 'commissionAmount',
  commissionRate: 'commissionRate',
  createdBy: 'createdBy',
  dealCode: 'dealCode',
  dealType: 'dealType',
  expectedClosingDate: 'expectedClosingDate',
  expectedRevenue: 'expectedRevenue',
  isDeleted: 'isDeleted',
  notes: 'notes',
  probability: 'probability',
  propertyId: 'propertyId',
  requiresApproval: 'requiresApproval',
  tags: 'tags',
  updatedBy: 'updatedBy',
  valueBreakdown: 'valueBreakdown',
  role: 'role',
  dealDate: 'dealDate',
  status: 'status',
  totalPaid: 'totalPaid',
  unitId: 'unitId',
  deletedAt: 'deletedAt',
  deletedBy: 'deletedBy',
  manualUniqueId: 'manualUniqueId',
  locationId: 'locationId',
  subsidiaryOptionId: 'subsidiaryOptionId',
  tid: 'tid'
} as const

export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


export const DealAgentScalarFieldEnum = {
  id: 'id',
  dealId: 'dealId',
  agentId: 'agentId',
  agentName: 'agentName',
  commissionShare: 'commissionShare',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type DealAgentScalarFieldEnum = (typeof DealAgentScalarFieldEnum)[keyof typeof DealAgentScalarFieldEnum]


export const DealPropertyScalarFieldEnum = {
  id: 'id',
  dealId: 'dealId',
  propertyId: 'propertyId',
  priceShare: 'priceShare',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DealPropertyScalarFieldEnum = (typeof DealPropertyScalarFieldEnum)[keyof typeof DealPropertyScalarFieldEnum]


export const StageHistoryScalarFieldEnum = {
  id: 'id',
  dealId: 'dealId',
  fromStage: 'fromStage',
  toStage: 'toStage',
  changedBy: 'changedBy',
  changedAt: 'changedAt',
  notes: 'notes',
  probability: 'probability'
} as const

export type StageHistoryScalarFieldEnum = (typeof StageHistoryScalarFieldEnum)[keyof typeof StageHistoryScalarFieldEnum]


export const CommunicationScalarFieldEnum = {
  id: 'id',
  leadId: 'leadId',
  clientId: 'clientId',
  channel: 'channel',
  content: 'content',
  createdAt: 'createdAt',
  activityDate: 'activityDate',
  activityOutcome: 'activityOutcome',
  activityType: 'activityType',
  assignedAgentId: 'assignedAgentId',
  attachments: 'attachments',
  contactPersonId: 'contactPersonId',
  contactPersonName: 'contactPersonName',
  createdBy: 'createdBy',
  dealId: 'dealId',
  isDeleted: 'isDeleted',
  nextFollowUpDate: 'nextFollowUpDate',
  recurrence: 'recurrence',
  recurrenceEndDate: 'recurrenceEndDate',
  reminderDate: 'reminderDate',
  reminderEnabled: 'reminderEnabled',
  subject: 'subject',
  tags: 'tags',
  updatedAt: 'updatedAt',
  voiceNoteUrl: 'voiceNoteUrl'
} as const

export type CommunicationScalarFieldEnum = (typeof CommunicationScalarFieldEnum)[keyof typeof CommunicationScalarFieldEnum]


export const CRMActivityScalarFieldEnum = {
  id: 'id',
  leadId: 'leadId',
  clientId: 'clientId',
  dealId: 'dealId',
  type: 'type',
  title: 'title',
  description: 'description',
  activityDate: 'activityDate',
  dueDate: 'dueDate',
  status: 'status',
  priority: 'priority',
  assignedTo: 'assignedTo',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CRMActivityScalarFieldEnum = (typeof CRMActivityScalarFieldEnum)[keyof typeof CRMActivityScalarFieldEnum]


export const TransactionCategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  description: 'description',
  defaultDebitAccountId: 'defaultDebitAccountId',
  defaultCreditAccountId: 'defaultCreditAccountId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TransactionCategoryScalarFieldEnum = (typeof TransactionCategoryScalarFieldEnum)[keyof typeof TransactionCategoryScalarFieldEnum]


export const TransactionScalarFieldEnum = {
  id: 'id',
  description: 'description',
  amount: 'amount',
  date: 'date',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  transactionCode: 'transactionCode',
  transactionType: 'transactionType',
  transactionCategoryId: 'transactionCategoryId',
  taxAmount: 'taxAmount',
  totalAmount: 'totalAmount',
  paymentMethod: 'paymentMethod',
  debitAccountId: 'debitAccountId',
  creditAccountId: 'creditAccountId',
  tenantId: 'tenantId',
  dealerId: 'dealerId',
  propertyId: 'propertyId',
  attachments: 'attachments',
  createdByUserId: 'createdByUserId',
  journalEntryId: 'journalEntryId'
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  invoiceNumber: 'invoiceNumber',
  amount: 'amount',
  dueDate: 'dueDate',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  tenantId: 'tenantId',
  propertyId: 'propertyId',
  billingDate: 'billingDate',
  taxPercent: 'taxPercent',
  taxAmount: 'taxAmount',
  discountAmount: 'discountAmount',
  totalAmount: 'totalAmount',
  remainingAmount: 'remainingAmount',
  lateFeeRule: 'lateFeeRule',
  termsAndConditions: 'termsAndConditions',
  attachments: 'attachments',
  tenantAccountId: 'tenantAccountId',
  incomeAccountId: 'incomeAccountId',
  createdByUserId: 'createdByUserId',
  journalEntryId: 'journalEntryId'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const PaymentScalarFieldEnum = {
  id: 'id',
  paymentId: 'paymentId',
  dealId: 'dealId',
  amount: 'amount',
  paymentType: 'paymentType',
  paymentMode: 'paymentMode',
  transactionId: 'transactionId',
  referenceNumber: 'referenceNumber',
  date: 'date',
  remarks: 'remarks',
  createdByUserId: 'createdByUserId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  installmentId: 'installmentId',
  refundOfPaymentId: 'refundOfPaymentId',
  deletedAt: 'deletedAt',
  deletedBy: 'deletedBy',
  manualUniqueId: 'manualUniqueId'
} as const

export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


export const TenantPaymentScalarFieldEnum = {
  id: 'id',
  paymentId: 'paymentId',
  amount: 'amount',
  method: 'method',
  date: 'date',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  tenantId: 'tenantId',
  invoiceId: 'invoiceId',
  bankAccountId: 'bankAccountId',
  referenceNumber: 'referenceNumber',
  notes: 'notes',
  attachments: 'attachments',
  allocatedAmount: 'allocatedAmount',
  overpaymentAmount: 'overpaymentAmount',
  allocations: 'allocations',
  receivableAccountId: 'receivableAccountId',
  advanceAccountId: 'advanceAccountId',
  createdByUserId: 'createdByUserId',
  journalEntryId: 'journalEntryId'
} as const

export type TenantPaymentScalarFieldEnum = (typeof TenantPaymentScalarFieldEnum)[keyof typeof TenantPaymentScalarFieldEnum]


export const MaintenanceTicketScalarFieldEnum = {
  id: 'id',
  ticketNumber: 'ticketNumber',
  tenantId: 'tenantId',
  unitId: 'unitId',
  category: 'category',
  title: 'title',
  description: 'description',
  priority: 'priority',
  status: 'status',
  assignedTo: 'assignedTo',
  assignedToName: 'assignedToName',
  photos: 'photos',
  technicianNotes: 'technicianNotes',
  estimatedCost: 'estimatedCost',
  actualCost: 'actualCost',
  completedAt: 'completedAt',
  tenantRating: 'tenantRating',
  tenantFeedback: 'tenantFeedback',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MaintenanceTicketScalarFieldEnum = (typeof MaintenanceTicketScalarFieldEnum)[keyof typeof MaintenanceTicketScalarFieldEnum]


export const MaintenanceActivityScalarFieldEnum = {
  id: 'id',
  ticketId: 'ticketId',
  action: 'action',
  description: 'description',
  performedBy: 'performedBy',
  performedAt: 'performedAt',
  metadata: 'metadata'
} as const

export type MaintenanceActivityScalarFieldEnum = (typeof MaintenanceActivityScalarFieldEnum)[keyof typeof MaintenanceActivityScalarFieldEnum]


export const NoticeToVacateScalarFieldEnum = {
  id: 'id',
  noticeNumber: 'noticeNumber',
  tenantId: 'tenantId',
  unitId: 'unitId',
  reason: 'reason',
  moveOutDate: 'moveOutDate',
  supportingDocs: 'supportingDocs',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  rejectionReason: 'rejectionReason',
  emailSent: 'emailSent',
  emailSentAt: 'emailSentAt',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NoticeToVacateScalarFieldEnum = (typeof NoticeToVacateScalarFieldEnum)[keyof typeof NoticeToVacateScalarFieldEnum]


export const RentReminderScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  invoiceId: 'invoiceId',
  reminderType: 'reminderType',
  message: 'message',
  sendDate: 'sendDate',
  sentAt: 'sentAt',
  isSent: 'isSent',
  isRead: 'isRead',
  readAt: 'readAt',
  createdAt: 'createdAt'
} as const

export type RentReminderScalarFieldEnum = (typeof RentReminderScalarFieldEnum)[keyof typeof RentReminderScalarFieldEnum]


export const TenantLedgerScalarFieldEnum = {
  id: 'id',
  ledgerNumber: 'ledgerNumber',
  tenantId: 'tenantId',
  entryDate: 'entryDate',
  entryType: 'entryType',
  description: 'description',
  amount: 'amount',
  balance: 'balance',
  referenceId: 'referenceId',
  referenceType: 'referenceType',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantLedgerScalarFieldEnum = (typeof TenantLedgerScalarFieldEnum)[keyof typeof TenantLedgerScalarFieldEnum]


export const ReceiptScalarFieldEnum = {
  id: 'id',
  receiptNumber: 'receiptNumber',
  tenantId: 'tenantId',
  paymentId: 'paymentId',
  invoiceId: 'invoiceId',
  amount: 'amount',
  paymentMethod: 'paymentMethod',
  receiptDate: 'receiptDate',
  receiptUrl: 'receiptUrl',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


export const AnnouncementScalarFieldEnum = {
  id: 'id',
  title: 'title',
  content: 'content',
  type: 'type',
  priority: 'priority',
  targetAudience: 'targetAudience',
  targetTenantIds: 'targetTenantIds',
  targetPropertyIds: 'targetPropertyIds',
  attachments: 'attachments',
  isActive: 'isActive',
  expiresAt: 'expiresAt',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


export const RevenueSummaryScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  month: 'month',
  totalRevenue: 'totalRevenue',
  rentRevenue: 'rentRevenue',
  otherRevenue: 'otherRevenue',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RevenueSummaryScalarFieldEnum = (typeof RevenueSummaryScalarFieldEnum)[keyof typeof RevenueSummaryScalarFieldEnum]


export const ExpenseSummaryScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  month: 'month',
  totalExpenses: 'totalExpenses',
  maintenanceExpenses: 'maintenanceExpenses',
  utilityExpenses: 'utilityExpenses',
  otherExpenses: 'otherExpenses',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExpenseSummaryScalarFieldEnum = (typeof ExpenseSummaryScalarFieldEnum)[keyof typeof ExpenseSummaryScalarFieldEnum]


export const VoucherScalarFieldEnum = {
  id: 'id',
  voucherNumber: 'voucherNumber',
  type: 'type',
  date: 'date',
  postingDate: 'postingDate',
  paymentMethod: 'paymentMethod',
  accountId: 'accountId',
  expenseCategoryId: 'expenseCategoryId',
  description: 'description',
  referenceNumber: 'referenceNumber',
  amount: 'amount',
  status: 'status',
  attachments: 'attachments',
  preparedByUserId: 'preparedByUserId',
  approvedByUserId: 'approvedByUserId',
  postedByUserId: 'postedByUserId',
  postedAt: 'postedAt',
  journalEntryId: 'journalEntryId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  dealId: 'dealId',
  propertyId: 'propertyId',
  unitId: 'unitId',
  payeeType: 'payeeType',
  payeeId: 'payeeId',
  reversedVoucherId: 'reversedVoucherId',
  reversedByUserId: 'reversedByUserId',
  reversedAt: 'reversedAt'
} as const

export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


export const VoucherLineScalarFieldEnum = {
  id: 'id',
  voucherId: 'voucherId',
  accountId: 'accountId',
  debit: 'debit',
  credit: 'credit',
  description: 'description',
  propertyId: 'propertyId',
  unitId: 'unitId',
  entityAccountBindingId: 'entityAccountBindingId'
} as const

export type VoucherLineScalarFieldEnum = (typeof VoucherLineScalarFieldEnum)[keyof typeof VoucherLineScalarFieldEnum]


export const CommissionScalarFieldEnum = {
  id: 'id',
  dealerId: 'dealerId',
  saleId: 'saleId',
  rate: 'rate',
  amount: 'amount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  commissionType: 'commissionType'
} as const

export type CommissionScalarFieldEnum = (typeof CommissionScalarFieldEnum)[keyof typeof CommissionScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  type: 'type',
  description: 'description',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  parentId: 'parentId',
  isPostable: 'isPostable',
  cashFlowCategory: 'cashFlowCategory',
  level: 'level',
  accountType: 'accountType',
  normalBalance: 'normalBalance',
  trustFlag: 'trustFlag'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const JournalEntryScalarFieldEnum = {
  id: 'id',
  voucherNo: 'voucherNo',
  date: 'date',
  description: 'description',
  narration: 'narration',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  entryNumber: 'entryNumber',
  attachments: 'attachments',
  preparedByUserId: 'preparedByUserId',
  approvedByUserId: 'approvedByUserId'
} as const

export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


export const JournalLineScalarFieldEnum = {
  id: 'id',
  entryId: 'entryId',
  accountId: 'accountId',
  debit: 'debit',
  credit: 'credit',
  description: 'description',
  constructionProjectId: 'constructionProjectId',
  costCodeId: 'costCodeId',
  sourceModule: 'sourceModule',
  referenceDocumentId: 'referenceDocumentId',
  approvalMetadata: 'approvalMetadata'
} as const

export type JournalLineScalarFieldEnum = (typeof JournalLineScalarFieldEnum)[keyof typeof JournalLineScalarFieldEnum]


export const LedgerEntryScalarFieldEnum = {
  id: 'id',
  dealId: 'dealId',
  paymentId: 'paymentId',
  accountDebit: 'accountDebit',
  accountCredit: 'accountCredit',
  amount: 'amount',
  remarks: 'remarks',
  date: 'date',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  deletedBy: 'deletedBy',
  debitAccountId: 'debitAccountId',
  creditAccountId: 'creditAccountId'
} as const

export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


export const PropertyExpenseScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  category: 'category',
  amount: 'amount',
  date: 'date',
  description: 'description',
  attachments: 'attachments',
  financeLedgerId: 'financeLedgerId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PropertyExpenseScalarFieldEnum = (typeof PropertyExpenseScalarFieldEnum)[keyof typeof PropertyExpenseScalarFieldEnum]


export const TenancyScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  tenantId: 'tenantId',
  leaseId: 'leaseId',
  leaseStart: 'leaseStart',
  leaseEnd: 'leaseEnd',
  monthlyRent: 'monthlyRent',
  nextInvoiceDate: 'nextInvoiceDate',
  status: 'status',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenancyScalarFieldEnum = (typeof TenancyScalarFieldEnum)[keyof typeof TenancyScalarFieldEnum]


export const MaintenanceRequestScalarFieldEnum = {
  id: 'id',
  propertyId: 'propertyId',
  tenantId: 'tenantId',
  unitId: 'unitId',
  issueTitle: 'issueTitle',
  issueDescription: 'issueDescription',
  priority: 'priority',
  status: 'status',
  assignedTo: 'assignedTo',
  assignedToName: 'assignedToName',
  attachments: 'attachments',
  estimatedCost: 'estimatedCost',
  actualCost: 'actualCost',
  completedAt: 'completedAt',
  financeLedgerId: 'financeLedgerId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MaintenanceRequestScalarFieldEnum = (typeof MaintenanceRequestScalarFieldEnum)[keyof typeof MaintenanceRequestScalarFieldEnum]


export const FinanceLedgerScalarFieldEnum = {
  id: 'id',
  referenceType: 'referenceType',
  referenceId: 'referenceId',
  category: 'category',
  amount: 'amount',
  date: 'date',
  notes: 'notes',
  description: 'description',
  propertyId: 'propertyId',
  tenantId: 'tenantId',
  dealId: 'dealId',
  payrollId: 'payrollId',
  invoiceId: 'invoiceId',
  paymentId: 'paymentId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FinanceLedgerScalarFieldEnum = (typeof FinanceLedgerScalarFieldEnum)[keyof typeof FinanceLedgerScalarFieldEnum]


export const AttachmentScalarFieldEnum = {
  id: 'id',
  fileName: 'fileName',
  fileUrl: 'fileUrl',
  fileType: 'fileType',
  fileSize: 'fileSize',
  entityType: 'entityType',
  entityId: 'entityId',
  propertyId: 'propertyId',
  tenantId: 'tenantId',
  uploadedBy: 'uploadedBy',
  description: 'description',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


export const DropdownCategoryScalarFieldEnum = {
  id: 'id',
  key: 'key',
  name: 'name',
  description: 'description',
  metadata: 'metadata',
  isActive: 'isActive',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DropdownCategoryScalarFieldEnum = (typeof DropdownCategoryScalarFieldEnum)[keyof typeof DropdownCategoryScalarFieldEnum]


export const DropdownOptionScalarFieldEnum = {
  id: 'id',
  categoryId: 'categoryId',
  value: 'value',
  label: 'label',
  sortOrder: 'sortOrder',
  metadata: 'metadata',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DropdownOptionScalarFieldEnum = (typeof DropdownOptionScalarFieldEnum)[keyof typeof DropdownOptionScalarFieldEnum]


export const AmenityScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  icon: 'icon',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


export const DealerPaymentScalarFieldEnum = {
  id: 'id',
  dealerId: 'dealerId',
  amount: 'amount',
  paidAt: 'paidAt',
  ledgerEntryId: 'ledgerEntryId',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DealerPaymentScalarFieldEnum = (typeof DealerPaymentScalarFieldEnum)[keyof typeof DealerPaymentScalarFieldEnum]


export const PaymentPlanScalarFieldEnum = {
  id: 'id',
  dealId: 'dealId',
  clientId: 'clientId',
  numberOfInstallments: 'numberOfInstallments',
  totalAmount: 'totalAmount',
  startDate: 'startDate',
  notes: 'notes',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  totalExpected: 'totalExpected',
  totalPaid: 'totalPaid',
  remaining: 'remaining',
  status: 'status',
  downPayment: 'downPayment',
  installmentType: 'installmentType'
} as const

export type PaymentPlanScalarFieldEnum = (typeof PaymentPlanScalarFieldEnum)[keyof typeof PaymentPlanScalarFieldEnum]


export const DealInstallmentScalarFieldEnum = {
  id: 'id',
  paymentPlanId: 'paymentPlanId',
  dealId: 'dealId',
  clientId: 'clientId',
  installmentNumber: 'installmentNumber',
  amount: 'amount',
  dueDate: 'dueDate',
  paidDate: 'paidDate',
  status: 'status',
  paidAmount: 'paidAmount',
  paymentMode: 'paymentMode',
  notes: 'notes',
  ledgerEntryId: 'ledgerEntryId',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  remaining: 'remaining',
  type: 'type'
} as const

export type DealInstallmentScalarFieldEnum = (typeof DealInstallmentScalarFieldEnum)[keyof typeof DealInstallmentScalarFieldEnum]


export const DealerLedgerScalarFieldEnum = {
  id: 'id',
  dealerId: 'dealerId',
  dealId: 'dealId',
  clientId: 'clientId',
  entryType: 'entryType',
  amount: 'amount',
  balance: 'balance',
  description: 'description',
  referenceId: 'referenceId',
  referenceType: 'referenceType',
  ledgerEntryId: 'ledgerEntryId',
  date: 'date',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DealerLedgerScalarFieldEnum = (typeof DealerLedgerScalarFieldEnum)[keyof typeof DealerLedgerScalarFieldEnum]


export const AccountAliasScalarFieldEnum = {
  id: 'id',
  alias: 'alias',
  accountId: 'accountId',
  createdAt: 'createdAt'
} as const

export type AccountAliasScalarFieldEnum = (typeof AccountAliasScalarFieldEnum)[keyof typeof AccountAliasScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  entityType: 'entityType',
  entityId: 'entityId',
  action: 'action',
  userId: 'userId',
  userName: 'userName',
  userRole: 'userRole',
  oldValues: 'oldValues',
  newValues: 'newValues',
  changes: 'changes',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  description: 'description',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const DealReceiptScalarFieldEnum = {
  id: 'id',
  receiptNo: 'receiptNo',
  dealId: 'dealId',
  clientId: 'clientId',
  amount: 'amount',
  method: 'method',
  date: 'date',
  notes: 'notes',
  receivedBy: 'receivedBy',
  pdfUrl: 'pdfUrl',
  journalEntryId: 'journalEntryId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  manualUniqueId: 'manualUniqueId',
  referenceNumber: 'referenceNumber'
} as const

export type DealReceiptScalarFieldEnum = (typeof DealReceiptScalarFieldEnum)[keyof typeof DealReceiptScalarFieldEnum]


export const DealReceiptAllocationScalarFieldEnum = {
  id: 'id',
  receiptId: 'receiptId',
  installmentId: 'installmentId',
  amountAllocated: 'amountAllocated',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DealReceiptAllocationScalarFieldEnum = (typeof DealReceiptAllocationScalarFieldEnum)[keyof typeof DealReceiptAllocationScalarFieldEnum]


export const RefreshTokenScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  token: 'token',
  deviceId: 'deviceId',
  expiresAt: 'expiresAt',
  revoked: 'revoked',
  revokedAt: 'revokedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


export const CsrfTokenScalarFieldEnum = {
  id: 'id',
  token: 'token',
  sessionId: 'sessionId',
  deviceId: 'deviceId',
  userId: 'userId',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type CsrfTokenScalarFieldEnum = (typeof CsrfTokenScalarFieldEnum)[keyof typeof CsrfTokenScalarFieldEnum]


export const DeletedRecordScalarFieldEnum = {
  id: 'id',
  entityType: 'entityType',
  entityId: 'entityId',
  entityName: 'entityName',
  entityData: 'entityData',
  deletedBy: 'deletedBy',
  deletedByName: 'deletedByName',
  deletedAt: 'deletedAt',
  expiresAt: 'expiresAt'
} as const

export type DeletedRecordScalarFieldEnum = (typeof DeletedRecordScalarFieldEnum)[keyof typeof DeletedRecordScalarFieldEnum]


export const SequenceScalarFieldEnum = {
  id: 'id',
  prefix: 'prefix',
  current: 'current',
  updatedAt: 'updatedAt'
} as const

export type SequenceScalarFieldEnum = (typeof SequenceScalarFieldEnum)[keyof typeof SequenceScalarFieldEnum]


export const EntityAccountBindingScalarFieldEnum = {
  id: 'id',
  entityType: 'entityType',
  entityId: 'entityId',
  accountId: 'accountId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy'
} as const

export type EntityAccountBindingScalarFieldEnum = (typeof EntityAccountBindingScalarFieldEnum)[keyof typeof EntityAccountBindingScalarFieldEnum]


export const EntityMetadataScalarFieldEnum = {
  id: 'id',
  entityType: 'entityType',
  entityId: 'entityId',
  notes: 'notes',
  references: 'references',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EntityMetadataScalarFieldEnum = (typeof EntityMetadataScalarFieldEnum)[keyof typeof EntityMetadataScalarFieldEnum]


export const ConstructionProjectScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  propertyId: 'propertyId',
  status: 'status',
  accountingMode: 'accountingMode',
  costCodeMandatory: 'costCodeMandatory',
  budgetEnforcement: 'budgetEnforcement',
  startDate: 'startDate',
  endDate: 'endDate',
  budgetAmount: 'budgetAmount',
  actualCost: 'actualCost',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionProjectScalarFieldEnum = (typeof ConstructionProjectScalarFieldEnum)[keyof typeof ConstructionProjectScalarFieldEnum]


export const CostCodeScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  level: 'level',
  parentId: 'parentId',
  description: 'description',
  isActive: 'isActive',
  projectId: 'projectId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CostCodeScalarFieldEnum = (typeof CostCodeScalarFieldEnum)[keyof typeof CostCodeScalarFieldEnum]


export const ConstructionDailyLogScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  logDate: 'logDate',
  weather: 'weather',
  siteActivities: 'siteActivities',
  laborHours: 'laborHours',
  equipmentHours: 'equipmentHours',
  notes: 'notes',
  attachments: 'attachments',
  status: 'status',
  submittedBy: 'submittedBy',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionDailyLogScalarFieldEnum = (typeof ConstructionDailyLogScalarFieldEnum)[keyof typeof ConstructionDailyLogScalarFieldEnum]


export const ConstructionCrewScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  crewLeadId: 'crewLeadId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionCrewScalarFieldEnum = (typeof ConstructionCrewScalarFieldEnum)[keyof typeof ConstructionCrewScalarFieldEnum]


export const ConstructionLaborScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  costCodeId: 'costCodeId',
  crewId: 'crewId',
  employeeId: 'employeeId',
  workDate: 'workDate',
  hours: 'hours',
  rate: 'rate',
  amount: 'amount',
  description: 'description',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  journalEntryId: 'journalEntryId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionLaborScalarFieldEnum = (typeof ConstructionLaborScalarFieldEnum)[keyof typeof ConstructionLaborScalarFieldEnum]


export const ConstructionEquipmentScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  type: 'type',
  make: 'make',
  model: 'model',
  serialNumber: 'serialNumber',
  hourlyRate: 'hourlyRate',
  dailyRate: 'dailyRate',
  costingMethod: 'costingMethod',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionEquipmentScalarFieldEnum = (typeof ConstructionEquipmentScalarFieldEnum)[keyof typeof ConstructionEquipmentScalarFieldEnum]


export const ConstructionEquipmentUsageScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  costCodeId: 'costCodeId',
  equipmentId: 'equipmentId',
  usageDate: 'usageDate',
  hours: 'hours',
  days: 'days',
  amount: 'amount',
  description: 'description',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  journalEntryId: 'journalEntryId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionEquipmentUsageScalarFieldEnum = (typeof ConstructionEquipmentUsageScalarFieldEnum)[keyof typeof ConstructionEquipmentUsageScalarFieldEnum]


export const ConstructionInventoryItemScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  category: 'category',
  unit: 'unit',
  unitPrice: 'unitPrice',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionInventoryItemScalarFieldEnum = (typeof ConstructionInventoryItemScalarFieldEnum)[keyof typeof ConstructionInventoryItemScalarFieldEnum]


export const ConstructionWarehouseScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  location: 'location',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionWarehouseScalarFieldEnum = (typeof ConstructionWarehouseScalarFieldEnum)[keyof typeof ConstructionWarehouseScalarFieldEnum]


export const ConstructionStockBalanceScalarFieldEnum = {
  id: 'id',
  warehouseId: 'warehouseId',
  itemId: 'itemId',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  lastUpdated: 'lastUpdated'
} as const

export type ConstructionStockBalanceScalarFieldEnum = (typeof ConstructionStockBalanceScalarFieldEnum)[keyof typeof ConstructionStockBalanceScalarFieldEnum]


export const ConstructionGRNScalarFieldEnum = {
  id: 'id',
  grnNumber: 'grnNumber',
  warehouseId: 'warehouseId',
  projectId: 'projectId',
  supplierName: 'supplierName',
  receiptDate: 'receiptDate',
  status: 'status',
  notes: 'notes',
  attachments: 'attachments',
  postedBy: 'postedBy',
  postedAt: 'postedAt',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionGRNScalarFieldEnum = (typeof ConstructionGRNScalarFieldEnum)[keyof typeof ConstructionGRNScalarFieldEnum]


export const ConstructionGRNItemScalarFieldEnum = {
  id: 'id',
  grnId: 'grnId',
  itemId: 'itemId',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  totalAmount: 'totalAmount'
} as const

export type ConstructionGRNItemScalarFieldEnum = (typeof ConstructionGRNItemScalarFieldEnum)[keyof typeof ConstructionGRNItemScalarFieldEnum]


export const ConstructionIssueScalarFieldEnum = {
  id: 'id',
  issueNumber: 'issueNumber',
  projectId: 'projectId',
  warehouseId: 'warehouseId',
  costCodeId: 'costCodeId',
  issueDate: 'issueDate',
  status: 'status',
  notes: 'notes',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  journalEntryId: 'journalEntryId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionIssueScalarFieldEnum = (typeof ConstructionIssueScalarFieldEnum)[keyof typeof ConstructionIssueScalarFieldEnum]


export const ConstructionIssueItemScalarFieldEnum = {
  id: 'id',
  issueId: 'issueId',
  itemId: 'itemId',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  totalAmount: 'totalAmount'
} as const

export type ConstructionIssueItemScalarFieldEnum = (typeof ConstructionIssueItemScalarFieldEnum)[keyof typeof ConstructionIssueItemScalarFieldEnum]


export const ConstructionConsumptionScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  costCodeId: 'costCodeId',
  itemId: 'itemId',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  totalAmount: 'totalAmount',
  consumptionDate: 'consumptionDate',
  description: 'description',
  status: 'status',
  approvedBy: 'approvedBy',
  approvedAt: 'approvedAt',
  journalEntryId: 'journalEntryId',
  isDeleted: 'isDeleted',
  createdBy: 'createdBy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionConsumptionScalarFieldEnum = (typeof ConstructionConsumptionScalarFieldEnum)[keyof typeof ConstructionConsumptionScalarFieldEnum]


export const ConstructionBudgetScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  costCodeId: 'costCodeId',
  budgetAmount: 'budgetAmount',
  description: 'description',
  fiscalYear: 'fiscalYear',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionBudgetScalarFieldEnum = (typeof ConstructionBudgetScalarFieldEnum)[keyof typeof ConstructionBudgetScalarFieldEnum]


export const ConstructionMilestoneScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  milestoneNumber: 'milestoneNumber',
  name: 'name',
  description: 'description',
  targetDate: 'targetDate',
  completionDate: 'completionDate',
  billingPercentage: 'billingPercentage',
  billingAmount: 'billingAmount',
  status: 'status',
  invoiceId: 'invoiceId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionMilestoneScalarFieldEnum = (typeof ConstructionMilestoneScalarFieldEnum)[keyof typeof ConstructionMilestoneScalarFieldEnum]


export const ConstructionPostingRuleScalarFieldEnum = {
  id: 'id',
  eventType: 'eventType',
  debitAccountCode: 'debitAccountCode',
  creditAccountCode: 'creditAccountCode',
  description: 'description',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConstructionPostingRuleScalarFieldEnum = (typeof ConstructionPostingRuleScalarFieldEnum)[keyof typeof ConstructionPostingRuleScalarFieldEnum]


export const ExportJobScalarFieldEnum = {
  id: 'id',
  module: 'module',
  tab: 'tab',
  userId: 'userId',
  status: 'status',
  format: 'format',
  scope: 'scope',
  customLimit: 'customLimit',
  filterJson: 'filterJson',
  columns: 'columns',
  dataShape: 'dataShape',
  rowCount: 'rowCount',
  error: 'error',
  fileUrl: 'fileUrl',
  fileName: 'fileName',
  createdAt: 'createdAt',
  startedAt: 'startedAt',
  completedAt: 'completedAt'
} as const

export type ExportJobScalarFieldEnum = (typeof ExportJobScalarFieldEnum)[keyof typeof ExportJobScalarFieldEnum]


export const FilterPresetScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  module: 'module',
  tab: 'tab',
  name: 'name',
  filterJson: 'filterJson',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FilterPresetScalarFieldEnum = (typeof FilterPresetScalarFieldEnum)[keyof typeof FilterPresetScalarFieldEnum]


export const FinancialOperationScalarFieldEnum = {
  id: 'id',
  operationType: 'operationType',
  status: 'status',
  reason: 'reason',
  amount: 'amount',
  partialAmount: 'partialAmount',
  requestedByUserId: 'requestedByUserId',
  approvedByUserId: 'approvedByUserId',
  approvedAt: 'approvedAt',
  postedByUserId: 'postedByUserId',
  postedAt: 'postedAt',
  voucherId: 'voucherId',
  dealId: 'dealId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FinancialOperationScalarFieldEnum = (typeof FinancialOperationScalarFieldEnum)[keyof typeof FinancialOperationScalarFieldEnum]


export const FinancialOperationLineScalarFieldEnum = {
  id: 'id',
  operationId: 'operationId',
  entityType: 'entityType',
  entityId: 'entityId',
  role: 'role',
  amount: 'amount',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type FinancialOperationLineScalarFieldEnum = (typeof FinancialOperationLineScalarFieldEnum)[keyof typeof FinancialOperationLineScalarFieldEnum]


export const FinancialOperationReferenceScalarFieldEnum = {
  id: 'id',
  operationId: 'operationId',
  refType: 'refType',
  refId: 'refId',
  role: 'role',
  createdAt: 'createdAt'
} as const

export type FinancialOperationReferenceScalarFieldEnum = (typeof FinancialOperationReferenceScalarFieldEnum)[keyof typeof FinancialOperationReferenceScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'FinancialOperationType'
 */
export type EnumFinancialOperationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialOperationType'>
    


/**
 * Reference to a field of type 'FinancialOperationType[]'
 */
export type ListEnumFinancialOperationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialOperationType[]'>
    


/**
 * Reference to a field of type 'FinancialOperationStatus'
 */
export type EnumFinancialOperationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialOperationStatus'>
    


/**
 * Reference to a field of type 'FinancialOperationStatus[]'
 */
export type ListEnumFinancialOperationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialOperationStatus[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  role?: Prisma.RoleOmit
  rolePermission?: Prisma.RolePermissionOmit
  permissionAuditLog?: Prisma.PermissionAuditLogOmit
  actionAuditLog?: Prisma.ActionAuditLogOmit
  roleLifecycleAuditLog?: Prisma.RoleLifecycleAuditLogOmit
  roleInviteLink?: Prisma.RoleInviteLinkOmit
  deviceApproval?: Prisma.DeviceApprovalOmit
  notification?: Prisma.NotificationOmit
  property?: Prisma.PropertyOmit
  location?: Prisma.LocationOmit
  propertySubsidiary?: Prisma.PropertySubsidiaryOmit
  subsidiaryOption?: Prisma.SubsidiaryOptionOmit
  block?: Prisma.BlockOmit
  floor?: Prisma.FloorOmit
  unit?: Prisma.UnitOmit
  tenant?: Prisma.TenantOmit
  lease?: Prisma.LeaseOmit
  sale?: Prisma.SaleOmit
  saleInstallment?: Prisma.SaleInstallmentOmit
  buyer?: Prisma.BuyerOmit
  activity?: Prisma.ActivityOmit
  message?: Prisma.MessageOmit
  department?: Prisma.DepartmentOmit
  employee?: Prisma.EmployeeOmit
  attendance?: Prisma.AttendanceOmit
  attendanceCorrection?: Prisma.AttendanceCorrectionOmit
  payroll?: Prisma.PayrollOmit
  payrollAllowance?: Prisma.PayrollAllowanceOmit
  payrollDeduction?: Prisma.PayrollDeductionOmit
  payrollPayment?: Prisma.PayrollPaymentOmit
  salaryHistory?: Prisma.SalaryHistoryOmit
  leaveRequest?: Prisma.LeaveRequestOmit
  leaveBalance?: Prisma.LeaveBalanceOmit
  publicHoliday?: Prisma.PublicHolidayOmit
  lead?: Prisma.LeadOmit
  leadImportBatch?: Prisma.LeadImportBatchOmit
  leadImportRow?: Prisma.LeadImportRowOmit
  client?: Prisma.ClientOmit
  contactPerson?: Prisma.ContactPersonOmit
  dealer?: Prisma.DealerOmit
  dealerReview?: Prisma.DealerReviewOmit
  deal?: Prisma.DealOmit
  dealAgent?: Prisma.DealAgentOmit
  dealProperty?: Prisma.DealPropertyOmit
  stageHistory?: Prisma.StageHistoryOmit
  communication?: Prisma.CommunicationOmit
  cRMActivity?: Prisma.CRMActivityOmit
  transactionCategory?: Prisma.TransactionCategoryOmit
  transaction?: Prisma.TransactionOmit
  invoice?: Prisma.InvoiceOmit
  payment?: Prisma.PaymentOmit
  tenantPayment?: Prisma.TenantPaymentOmit
  maintenanceTicket?: Prisma.MaintenanceTicketOmit
  maintenanceActivity?: Prisma.MaintenanceActivityOmit
  noticeToVacate?: Prisma.NoticeToVacateOmit
  rentReminder?: Prisma.RentReminderOmit
  tenantLedger?: Prisma.TenantLedgerOmit
  receipt?: Prisma.ReceiptOmit
  announcement?: Prisma.AnnouncementOmit
  revenueSummary?: Prisma.RevenueSummaryOmit
  expenseSummary?: Prisma.ExpenseSummaryOmit
  voucher?: Prisma.VoucherOmit
  voucherLine?: Prisma.VoucherLineOmit
  commission?: Prisma.CommissionOmit
  account?: Prisma.AccountOmit
  journalEntry?: Prisma.JournalEntryOmit
  journalLine?: Prisma.JournalLineOmit
  ledgerEntry?: Prisma.LedgerEntryOmit
  propertyExpense?: Prisma.PropertyExpenseOmit
  tenancy?: Prisma.TenancyOmit
  maintenanceRequest?: Prisma.MaintenanceRequestOmit
  financeLedger?: Prisma.FinanceLedgerOmit
  attachment?: Prisma.AttachmentOmit
  dropdownCategory?: Prisma.DropdownCategoryOmit
  dropdownOption?: Prisma.DropdownOptionOmit
  amenity?: Prisma.AmenityOmit
  dealerPayment?: Prisma.DealerPaymentOmit
  paymentPlan?: Prisma.PaymentPlanOmit
  dealInstallment?: Prisma.DealInstallmentOmit
  dealerLedger?: Prisma.DealerLedgerOmit
  accountAlias?: Prisma.AccountAliasOmit
  auditLog?: Prisma.AuditLogOmit
  dealReceipt?: Prisma.DealReceiptOmit
  dealReceiptAllocation?: Prisma.DealReceiptAllocationOmit
  refreshToken?: Prisma.RefreshTokenOmit
  csrfToken?: Prisma.CsrfTokenOmit
  deletedRecord?: Prisma.DeletedRecordOmit
  sequence?: Prisma.SequenceOmit
  entityAccountBinding?: Prisma.EntityAccountBindingOmit
  entityMetadata?: Prisma.EntityMetadataOmit
  constructionProject?: Prisma.ConstructionProjectOmit
  costCode?: Prisma.CostCodeOmit
  constructionDailyLog?: Prisma.ConstructionDailyLogOmit
  constructionCrew?: Prisma.ConstructionCrewOmit
  constructionLabor?: Prisma.ConstructionLaborOmit
  constructionEquipment?: Prisma.ConstructionEquipmentOmit
  constructionEquipmentUsage?: Prisma.ConstructionEquipmentUsageOmit
  constructionInventoryItem?: Prisma.ConstructionInventoryItemOmit
  constructionWarehouse?: Prisma.ConstructionWarehouseOmit
  constructionStockBalance?: Prisma.ConstructionStockBalanceOmit
  constructionGRN?: Prisma.ConstructionGRNOmit
  constructionGRNItem?: Prisma.ConstructionGRNItemOmit
  constructionIssue?: Prisma.ConstructionIssueOmit
  constructionIssueItem?: Prisma.ConstructionIssueItemOmit
  constructionConsumption?: Prisma.ConstructionConsumptionOmit
  constructionBudget?: Prisma.ConstructionBudgetOmit
  constructionMilestone?: Prisma.ConstructionMilestoneOmit
  constructionPostingRule?: Prisma.ConstructionPostingRuleOmit
  exportJob?: Prisma.ExportJobOmit
  filterPreset?: Prisma.FilterPresetOmit
  financialOperation?: Prisma.FinancialOperationOmit
  financialOperationLine?: Prisma.FinancialOperationLineOmit
  financialOperationReference?: Prisma.FinancialOperationReferenceOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

